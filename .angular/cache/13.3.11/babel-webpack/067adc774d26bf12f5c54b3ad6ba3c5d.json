{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Injector, NgModule } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { tap } from 'rxjs/operators';\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTIONS');\nconst STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');\n\n/**\n * The following key is used to store the entire serialized\n * state when there's no specific state provided.\n */\nconst DEFAULT_STATE_KEY = '@@STATE';\nfunction storageOptionsFactory(options) {\n  return Object.assign({\n    key: [DEFAULT_STATE_KEY],\n    storage: 0 /* LocalStorage */,\n    serialize: JSON.stringify,\n    deserialize: JSON.parse,\n    beforeSerialize: obj => obj,\n    afterDeserialize: obj => obj\n  }, options);\n}\nfunction engineFactory(options, platformId) {\n  if (isPlatformServer(platformId)) {\n    return null;\n  }\n  if (options.storage === 0 /* LocalStorage */) {\n    return localStorage;\n  } else if (options.storage === 1 /* SessionStorage */) {\n    return sessionStorage;\n  }\n  return null;\n}\nfunction getStorageKey(key, options) {\n  // Prepends the `namespace` option to any key if it's been provided by a user.\n  // So `@@STATE` becomes `my-app:@@STATE`.\n  return options && options.namespace ? `${options.namespace}:${key}` : key;\n}\n\n/** Determines whether the provided key has the following structure. */\nfunction isKeyWithExplicitEngine(key) {\n  return key != null && !!key.engine;\n}\n/** This symbol is used to store the metadata on state classes. */\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nfunction exctractStringKey(storageKey) {\n  // Extract the actual key out of the `{ key, engine }` structure.\n  if (isKeyWithExplicitEngine(storageKey)) {\n    storageKey = storageKey.key;\n  }\n  // Given the `storageKey` is a class, for instance, `AuthState`.\n  // We should retrieve its metadata and the `name` property.\n  // The `name` property might be a string (state name) or a state token.\n  if (storageKey.hasOwnProperty(META_OPTIONS_KEY)) {\n    storageKey = storageKey[META_OPTIONS_KEY].name;\n  }\n  return storageKey instanceof StateToken ? storageKey.getName() : storageKey;\n}\nconst FINAL_NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('FINAL_NGXS_STORAGE_PLUGIN_OPTIONS');\nfunction createFinalStoragePluginOptions(injector, options) {\n  const storageKeys = Array.isArray(options.key) ? options.key : [options.key];\n  const keysWithEngines = storageKeys.map(storageKey => {\n    const key = exctractStringKey(storageKey);\n    const engine = isKeyWithExplicitEngine(storageKey) ? injector.get(storageKey.engine) : injector.get(STORAGE_ENGINE);\n    return {\n      key,\n      engine\n    };\n  });\n  return Object.assign(Object.assign({}, options), {\n    keysWithEngines\n  });\n}\nclass NgxsStoragePlugin {\n  constructor(_options, _platformId) {\n    this._options = _options;\n    this._platformId = _platformId;\n    this._keysWithEngines = this._options.keysWithEngines;\n    // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n    this._usesDefaultStateKey = this._keysWithEngines.length === 1 && this._keysWithEngines[0].key === DEFAULT_STATE_KEY;\n  }\n  handle(state, event, next) {\n    if (isPlatformServer(this._platformId)) {\n      return next(state, event);\n    }\n    const matches = actionMatcher(event);\n    const isInitAction = matches(InitState);\n    const isUpdateAction = matches(UpdateState);\n    const isInitOrUpdateAction = isInitAction || isUpdateAction;\n    let hasMigration = false;\n    if (isInitOrUpdateAction) {\n      const addedStates = isUpdateAction && event.addedStates;\n      for (const {\n        key,\n        engine\n      } of this._keysWithEngines) {\n        // We're checking what states have been added by NGXS and if any of these states should be handled by\n        // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n        // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n        // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n        if (!this._usesDefaultStateKey && addedStates) {\n          // We support providing keys that can be deeply nested via dot notation, for instance,\n          // `keys: ['myState.myProperty']` is a valid key.\n          // The state name should always go first. The below code checks if the `key` includes dot\n          // notation and extracts the state name out of the key.\n          // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n          const dotNotationIndex = key.indexOf(DOT);\n          const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n          if (!addedStates.hasOwnProperty(stateName)) {\n            continue;\n          }\n        }\n        const storageKey = getStorageKey(key, this._options);\n        let storedValue = engine.getItem(storageKey);\n        if (storedValue !== 'undefined' && storedValue != null) {\n          try {\n            const newVal = this._options.deserialize(storedValue);\n            storedValue = this._options.afterDeserialize(newVal, key);\n          } catch (_a) {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n            }\n            storedValue = {};\n          }\n          if (this._options.migrations) {\n            this._options.migrations.forEach(strategy => {\n              const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n              const keyMatch = !strategy.key && this._usesDefaultStateKey || strategy.key === key;\n              if (versionMatch && keyMatch) {\n                storedValue = strategy.migrate(storedValue);\n                hasMigration = true;\n              }\n            });\n          }\n          if (!this._usesDefaultStateKey) {\n            state = setValue(state, key, storedValue);\n          } else {\n            // The `UpdateState` action is dispatched whenever the feature state is added.\n            // The below condition is met only when the `UpdateState` is dispatched.\n            // Let's assume that we have 2 states `counter` and `@ngxs/router-plugin` state.\n            // `CounterState` is provided on the root level when calling `NgxsModule.forRoot()`\n            // and `@ngxs/router-plugin` is provided as a feature state.\n            // The storage plugin may save the `counter` state value as `10` before.\n            // The `CounterState` may implement the `ngxsOnInit` hook and call `ctx.setState(999)`.\n            // The storage plugin will re-hydrate the whole state when the `RouterState` is registered,\n            // and the `counter` state will again equal `10` (not `999`).\n            if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n              storedValue = Object.keys(addedStates).reduce((accumulator, addedState) => {\n                // The `storedValue` may equal the whole state (when the default state key is used).\n                // If `addedStates` contains only `router` then we want to merge the state only\n                // with the `router` value.\n                // Let's assume that the `storedValue` is an object:\n                // `{ counter: 10, router: {...} }`\n                // This will pick only the `router` object from the `storedValue` and `counter`\n                // state will not be re-hydrated unnecessary.\n                if (storedValue.hasOwnProperty(addedState)) {\n                  accumulator[addedState] = storedValue[addedState];\n                }\n                return accumulator;\n              }, {});\n            }\n            state = Object.assign(Object.assign({}, state), storedValue);\n          }\n        }\n      }\n    }\n    return next(state, event).pipe(tap(nextState => {\n      if (!isInitOrUpdateAction || isInitOrUpdateAction && hasMigration) {\n        for (const {\n          key,\n          engine\n        } of this._keysWithEngines) {\n          let storedValue = nextState;\n          const storageKey = getStorageKey(key, this._options);\n          if (key !== DEFAULT_STATE_KEY) {\n            storedValue = getValue(nextState, key);\n          }\n          try {\n            const newStoredValue = this._options.beforeSerialize(storedValue, key);\n            engine.setItem(storageKey, this._options.serialize(newStoredValue));\n          } catch (error) {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n              if (error && (error.name === 'QuotaExceededError' || error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);\n              } else {\n                console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);\n              }\n            }\n          }\n        }\n      }\n    }));\n  }\n}\n/** @nocollapse */\nNgxsStoragePlugin.ɵfac = function NgxsStoragePlugin_Factory(t) {\n  return new (t || NgxsStoragePlugin)(i0.ɵɵinject(FINAL_NGXS_STORAGE_PLUGIN_OPTIONS), i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\nNgxsStoragePlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsStoragePlugin,\n  factory: NgxsStoragePlugin.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsStoragePlugin, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [FINAL_NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\nconst DOT = '.';\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nclass NgxsStoragePluginModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsStoragePluginModule,\n      providers: [{\n        provide: NGXS_PLUGINS,\n        useClass: NgxsStoragePlugin,\n        multi: true\n      }, {\n        provide: USER_OPTIONS,\n        useValue: options\n      }, {\n        provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: storageOptionsFactory,\n        deps: [USER_OPTIONS]\n      }, {\n        provide: STORAGE_ENGINE,\n        useFactory: engineFactory,\n        deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n      }, {\n        provide: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS,\n        useFactory: createFinalStoragePluginOptions,\n        deps: [Injector, NGXS_STORAGE_PLUGIN_OPTIONS]\n      }]\n    };\n  }\n}\n/** @nocollapse */\nNgxsStoragePluginModule.ɵfac = function NgxsStoragePluginModule_Factory(t) {\n  return new (t || NgxsStoragePluginModule)();\n};\n/** @nocollapse */\nNgxsStoragePluginModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsStoragePluginModule\n});\n/** @nocollapse */\nNgxsStoragePluginModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsStoragePluginModule, [{\n    type: NgModule\n  }], null, null);\n})();\nconst LOCAL_STORAGE_ENGINE = new InjectionToken('LOCAL_STORAGE_ENGINE', {\n  providedIn: 'root',\n  factory: () => localStorage\n});\nconst SESSION_STORAGE_ENGINE = new InjectionToken('SESSION_STORAGE_ENGINE', {\n  providedIn: 'root',\n  factory: () => sessionStorage\n});\n\n/**\n * The public api for consumers of @ngxs/storage-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LOCAL_STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, SESSION_STORAGE_ENGINE, STORAGE_ENGINE };","map":{"version":3,"names":["i0","InjectionToken","PLATFORM_ID","Injectable","Inject","Injector","NgModule","StateToken","actionMatcher","InitState","UpdateState","getValue","setValue","NGXS_PLUGINS","isPlatformServer","tap","NGXS_STORAGE_PLUGIN_OPTIONS","STORAGE_ENGINE","DEFAULT_STATE_KEY","storageOptionsFactory","options","Object","assign","key","storage","serialize","JSON","stringify","deserialize","parse","beforeSerialize","obj","afterDeserialize","engineFactory","platformId","localStorage","sessionStorage","getStorageKey","namespace","isKeyWithExplicitEngine","engine","META_OPTIONS_KEY","exctractStringKey","storageKey","hasOwnProperty","name","getName","FINAL_NGXS_STORAGE_PLUGIN_OPTIONS","createFinalStoragePluginOptions","injector","storageKeys","Array","isArray","keysWithEngines","map","get","NgxsStoragePlugin","constructor","_options","_platformId","_keysWithEngines","_usesDefaultStateKey","length","handle","state","event","next","matches","isInitAction","isUpdateAction","isInitOrUpdateAction","hasMigration","addedStates","dotNotationIndex","indexOf","DOT","stateName","slice","storedValue","getItem","newVal","_a","ngDevMode","console","error","migrations","forEach","strategy","versionMatch","version","versionKey","keyMatch","migrate","keys","reduce","accumulator","addedState","pipe","nextState","newStoredValue","setItem","ɵfac","NgxsStoragePlugin_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","ɵsetClassMetadata","type","undefined","decorators","args","USER_OPTIONS","NgxsStoragePluginModule","forRoot","ngModule","providers","provide","useClass","multi","useValue","useFactory","deps","NgxsStoragePluginModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","LOCAL_STORAGE_ENGINE","providedIn","SESSION_STORAGE_ENGINE"],"sources":["C:/Users/paddy/Documents/GitHub/pet_feeder_ui/pet-minder-ui/node_modules/@ngxs/storage-plugin/fesm2015/ngxs-storage-plugin.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Injector, NgModule } from '@angular/core';\nimport { StateToken, actionMatcher, InitState, UpdateState, getValue, setValue, NGXS_PLUGINS } from '@ngxs/store';\nimport { isPlatformServer } from '@angular/common';\nimport { tap } from 'rxjs/operators';\n\nconst NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('NGXS_STORAGE_PLUGIN_OPTIONS');\nconst STORAGE_ENGINE = new InjectionToken('STORAGE_ENGINE');\n\n/**\n * The following key is used to store the entire serialized\n * state when there's no specific state provided.\n */\nconst DEFAULT_STATE_KEY = '@@STATE';\nfunction storageOptionsFactory(options) {\n    return Object.assign({ key: [DEFAULT_STATE_KEY], storage: 0 /* LocalStorage */, serialize: JSON.stringify, deserialize: JSON.parse, beforeSerialize: obj => obj, afterDeserialize: obj => obj }, options);\n}\nfunction engineFactory(options, platformId) {\n    if (isPlatformServer(platformId)) {\n        return null;\n    }\n    if (options.storage === 0 /* LocalStorage */) {\n        return localStorage;\n    }\n    else if (options.storage === 1 /* SessionStorage */) {\n        return sessionStorage;\n    }\n    return null;\n}\nfunction getStorageKey(key, options) {\n    // Prepends the `namespace` option to any key if it's been provided by a user.\n    // So `@@STATE` becomes `my-app:@@STATE`.\n    return options && options.namespace ? `${options.namespace}:${key}` : key;\n}\n\n/** Determines whether the provided key has the following structure. */\nfunction isKeyWithExplicitEngine(key) {\n    return key != null && !!key.engine;\n}\n/** This symbol is used to store the metadata on state classes. */\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nfunction exctractStringKey(storageKey) {\n    // Extract the actual key out of the `{ key, engine }` structure.\n    if (isKeyWithExplicitEngine(storageKey)) {\n        storageKey = storageKey.key;\n    }\n    // Given the `storageKey` is a class, for instance, `AuthState`.\n    // We should retrieve its metadata and the `name` property.\n    // The `name` property might be a string (state name) or a state token.\n    if (storageKey.hasOwnProperty(META_OPTIONS_KEY)) {\n        storageKey = storageKey[META_OPTIONS_KEY].name;\n    }\n    return storageKey instanceof StateToken ? storageKey.getName() : storageKey;\n}\n\nconst FINAL_NGXS_STORAGE_PLUGIN_OPTIONS = new InjectionToken('FINAL_NGXS_STORAGE_PLUGIN_OPTIONS');\nfunction createFinalStoragePluginOptions(injector, options) {\n    const storageKeys = Array.isArray(options.key) ? options.key : [options.key];\n    const keysWithEngines = storageKeys.map((storageKey) => {\n        const key = exctractStringKey(storageKey);\n        const engine = isKeyWithExplicitEngine(storageKey)\n            ? injector.get(storageKey.engine)\n            : injector.get(STORAGE_ENGINE);\n        return { key, engine };\n    });\n    return Object.assign(Object.assign({}, options), { keysWithEngines });\n}\n\nclass NgxsStoragePlugin {\n    constructor(_options, _platformId) {\n        this._options = _options;\n        this._platformId = _platformId;\n        this._keysWithEngines = this._options.keysWithEngines;\n        // We default to `[DEFAULT_STATE_KEY]` if the user explicitly does not provide the `key` option.\n        this._usesDefaultStateKey = this._keysWithEngines.length === 1 && this._keysWithEngines[0].key === DEFAULT_STATE_KEY;\n    }\n    handle(state, event, next) {\n        if (isPlatformServer(this._platformId)) {\n            return next(state, event);\n        }\n        const matches = actionMatcher(event);\n        const isInitAction = matches(InitState);\n        const isUpdateAction = matches(UpdateState);\n        const isInitOrUpdateAction = isInitAction || isUpdateAction;\n        let hasMigration = false;\n        if (isInitOrUpdateAction) {\n            const addedStates = isUpdateAction && event.addedStates;\n            for (const { key, engine } of this._keysWithEngines) {\n                // We're checking what states have been added by NGXS and if any of these states should be handled by\n                // the storage plugin. For instance, we only want to deserialize the `auth` state, NGXS has added\n                // the `user` state, the storage plugin will be rerun and will do redundant deserialization.\n                // `usesDefaultStateKey` is necessary to check since `event.addedStates` never contains `@@STATE`.\n                if (!this._usesDefaultStateKey && addedStates) {\n                    // We support providing keys that can be deeply nested via dot notation, for instance,\n                    // `keys: ['myState.myProperty']` is a valid key.\n                    // The state name should always go first. The below code checks if the `key` includes dot\n                    // notation and extracts the state name out of the key.\n                    // Given the `key` is `myState.myProperty`, the `addedStates` will only contain `myState`.\n                    const dotNotationIndex = key.indexOf(DOT);\n                    const stateName = dotNotationIndex > -1 ? key.slice(0, dotNotationIndex) : key;\n                    if (!addedStates.hasOwnProperty(stateName)) {\n                        continue;\n                    }\n                }\n                const storageKey = getStorageKey(key, this._options);\n                let storedValue = engine.getItem(storageKey);\n                if (storedValue !== 'undefined' && storedValue != null) {\n                    try {\n                        const newVal = this._options.deserialize(storedValue);\n                        storedValue = this._options.afterDeserialize(newVal, key);\n                    }\n                    catch (_a) {\n                        // Caretaker note: we have still left the `typeof` condition in order to avoid\n                        // creating a breaking change for projects that still use the View Engine.\n                        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                            console.error(`Error ocurred while deserializing the ${storageKey} store value, falling back to empty object, the value obtained from the store: `, storedValue);\n                        }\n                        storedValue = {};\n                    }\n                    if (this._options.migrations) {\n                        this._options.migrations.forEach(strategy => {\n                            const versionMatch = strategy.version === getValue(storedValue, strategy.versionKey || 'version');\n                            const keyMatch = (!strategy.key && this._usesDefaultStateKey) || strategy.key === key;\n                            if (versionMatch && keyMatch) {\n                                storedValue = strategy.migrate(storedValue);\n                                hasMigration = true;\n                            }\n                        });\n                    }\n                    if (!this._usesDefaultStateKey) {\n                        state = setValue(state, key, storedValue);\n                    }\n                    else {\n                        // The `UpdateState` action is dispatched whenever the feature state is added.\n                        // The below condition is met only when the `UpdateState` is dispatched.\n                        // Let's assume that we have 2 states `counter` and `@ngxs/router-plugin` state.\n                        // `CounterState` is provided on the root level when calling `NgxsModule.forRoot()`\n                        // and `@ngxs/router-plugin` is provided as a feature state.\n                        // The storage plugin may save the `counter` state value as `10` before.\n                        // The `CounterState` may implement the `ngxsOnInit` hook and call `ctx.setState(999)`.\n                        // The storage plugin will re-hydrate the whole state when the `RouterState` is registered,\n                        // and the `counter` state will again equal `10` (not `999`).\n                        if (storedValue && addedStates && Object.keys(addedStates).length > 0) {\n                            storedValue = Object.keys(addedStates).reduce((accumulator, addedState) => {\n                                // The `storedValue` may equal the whole state (when the default state key is used).\n                                // If `addedStates` contains only `router` then we want to merge the state only\n                                // with the `router` value.\n                                // Let's assume that the `storedValue` is an object:\n                                // `{ counter: 10, router: {...} }`\n                                // This will pick only the `router` object from the `storedValue` and `counter`\n                                // state will not be re-hydrated unnecessary.\n                                if (storedValue.hasOwnProperty(addedState)) {\n                                    accumulator[addedState] = storedValue[addedState];\n                                }\n                                return accumulator;\n                            }, {});\n                        }\n                        state = Object.assign(Object.assign({}, state), storedValue);\n                    }\n                }\n            }\n        }\n        return next(state, event).pipe(tap(nextState => {\n            if (!isInitOrUpdateAction || (isInitOrUpdateAction && hasMigration)) {\n                for (const { key, engine } of this._keysWithEngines) {\n                    let storedValue = nextState;\n                    const storageKey = getStorageKey(key, this._options);\n                    if (key !== DEFAULT_STATE_KEY) {\n                        storedValue = getValue(nextState, key);\n                    }\n                    try {\n                        const newStoredValue = this._options.beforeSerialize(storedValue, key);\n                        engine.setItem(storageKey, this._options.serialize(newStoredValue));\n                    }\n                    catch (error) {\n                        // Caretaker note: we have still left the `typeof` condition in order to avoid\n                        // creating a breaking change for projects that still use the View Engine.\n                        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                            if (error &&\n                                (error.name === 'QuotaExceededError' ||\n                                    error.name === 'NS_ERROR_DOM_QUOTA_REACHED')) {\n                                console.error(`The ${storageKey} store value exceeds the browser storage quota: `, storedValue);\n                            }\n                            else {\n                                console.error(`Error ocurred while serializing the ${storageKey} store value, value not updated, the value obtained from the store: `, storedValue);\n                            }\n                        }\n                    }\n                }\n            }\n        }));\n    }\n}\n/** @nocollapse */ NgxsStoragePlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePlugin, deps: [{ token: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsStoragePlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePlugin });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePlugin, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [FINAL_NGXS_STORAGE_PLUGIN_OPTIONS]\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\nconst DOT = '.';\n\nconst USER_OPTIONS = new InjectionToken('USER_OPTIONS');\nclass NgxsStoragePluginModule {\n    static forRoot(options) {\n        return {\n            ngModule: NgxsStoragePluginModule,\n            providers: [\n                {\n                    provide: NGXS_PLUGINS,\n                    useClass: NgxsStoragePlugin,\n                    multi: true\n                },\n                {\n                    provide: USER_OPTIONS,\n                    useValue: options\n                },\n                {\n                    provide: NGXS_STORAGE_PLUGIN_OPTIONS,\n                    useFactory: storageOptionsFactory,\n                    deps: [USER_OPTIONS]\n                },\n                {\n                    provide: STORAGE_ENGINE,\n                    useFactory: engineFactory,\n                    deps: [NGXS_STORAGE_PLUGIN_OPTIONS, PLATFORM_ID]\n                },\n                {\n                    provide: FINAL_NGXS_STORAGE_PLUGIN_OPTIONS,\n                    useFactory: createFinalStoragePluginOptions,\n                    deps: [Injector, NGXS_STORAGE_PLUGIN_OPTIONS]\n                }\n            ]\n        };\n    }\n}\n/** @nocollapse */ NgxsStoragePluginModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePluginModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsStoragePluginModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePluginModule });\n/** @nocollapse */ NgxsStoragePluginModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePluginModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsStoragePluginModule, decorators: [{\n            type: NgModule\n        }] });\n\nconst LOCAL_STORAGE_ENGINE = new InjectionToken('LOCAL_STORAGE_ENGINE', {\n    providedIn: 'root',\n    factory: () => localStorage\n});\nconst SESSION_STORAGE_ENGINE = new InjectionToken('SESSION_STORAGE_ENGINE', {\n    providedIn: 'root',\n    factory: () => sessionStorage\n});\n\n/**\n * The public api for consumers of @ngxs/storage-plugin\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { LOCAL_STORAGE_ENGINE, NGXS_STORAGE_PLUGIN_OPTIONS, NgxsStoragePlugin, NgxsStoragePluginModule, SESSION_STORAGE_ENGINE, STORAGE_ENGINE };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}