{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, InitialState } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\nfunction throwStateNameError(name) {\n  throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n  throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n  throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n  throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n  throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n  throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n  return 'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' + 'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' + 'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })';\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n  return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n  throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n  throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n  throw new Error('Patching primitives is not supported.');\n}\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n  constructor(_ngZone, _platformId) {\n    this._ngZone = _ngZone;\n    this._platformId = _platformId;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      verifyZoneIsNotNooped(_ngZone);\n    }\n  }\n  enter(func) {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n    return this.runOutsideAngular(func);\n  }\n  leave(func) {\n    return this.runInsideAngular(func);\n  }\n  runInsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n  runOutsideAngular(func) {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n}\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵfac = function DispatchOutsideZoneNgxsExecutionStrategy_Factory(t) {\n  return new (t || DispatchOutsideZoneNgxsExecutionStrategy)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\nDispatchOutsideZoneNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DispatchOutsideZoneNgxsExecutionStrategy,\n  factory: DispatchOutsideZoneNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DispatchOutsideZoneNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.NgZone\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n  // `NoopNgZone` is not exposed publicly as it doesn't expect\n  // to be used outside of the core Angular code, thus we just have\n  // to check if the zone doesn't extend or instanceof `NgZone`.\n  if (ngZone instanceof NgZone) {\n    return;\n  }\n  console.warn(getZoneWarningMessage());\n}\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n  constructor() {\n    /**\n     * Defining the default state before module initialization\n     * This is convenient if we need to create a define our own set of states.\n     * @deprecated will be removed after v4\n     * (default: {})\n     */\n    this.defaultsState = {};\n    /**\n     * Defining shared selector options\n     */\n    this.selectorOptions = {\n      injectContainerState: true,\n      suppressErrors: true // TODO: default is true in v3, will change in v4\n    };\n\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n  }\n}\n/** @nocollapse */\nNgxsConfig.ɵfac = function NgxsConfig_Factory(t) {\n  return new (t || NgxsConfig)();\n};\n/** @nocollapse */\nNgxsConfig.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsConfig,\n  factory: NgxsConfig.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsConfig, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n}\nclass NoopNgxsExecutionStrategy {\n  enter(func) {\n    return func();\n  }\n  leave(func) {\n    return func();\n  }\n}\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵfac = function NoopNgxsExecutionStrategy_Factory(t) {\n  return new (t || NoopNgxsExecutionStrategy)();\n};\n/** @nocollapse */\nNoopNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NoopNgxsExecutionStrategy,\n  factory: NoopNgxsExecutionStrategy.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NoopNgxsExecutionStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n  providedIn: 'root',\n  factory: () => {\n    const injector = inject(INJECTOR);\n    const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n    return executionStrategy ? injector.get(executionStrategy) : injector.get(typeof ɵglobal.Zone !== 'undefined' ? DispatchOutsideZoneNgxsExecutionStrategy : NoopNgxsExecutionStrategy);\n  }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n    Object.defineProperty(target, META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n  return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n    Object.defineProperty(target, SELECTOR_META_KEY, {\n      value: defaultMetadata\n    });\n  }\n  return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n  return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n  const fn = new Function('store', 'return ' + expr + ';');\n  return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n  const findName = stateClass => {\n    const meta = stateClasses.find(g => g === stateClass);\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n      throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n    }\n    return meta[META_KEY].name;\n  };\n  return stateClasses.reduce((result, stateClass) => {\n    const {\n      name,\n      children\n    } = stateClass[META_KEY];\n    result[name] = (children || []).map(findName);\n    return result;\n  }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n  return states.reduce((result, stateClass) => {\n    const meta = stateClass[META_KEY];\n    result[meta.name] = stateClass;\n    return result;\n  }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n  const visit = (child, keyToFind) => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n  return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n  const sorted = [];\n  const visited = {};\n  const visit = (name, ancestors = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n    ancestors.push(name);\n    visited[name] = true;\n    graph[name].forEach(dep => {\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n        throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n      }\n      if (visited[dep]) {\n        return;\n      }\n      visit(dep, ancestors.slice(0));\n    });\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n  Object.keys(graph).forEach(k => visit(k));\n  return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject$1(obj) {\n  return typeof obj === 'object' && obj !== null || typeof obj === 'function';\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  } else {\n    return action.type;\n  }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n  const type1 = getActionTypeFromInstance(action1);\n  return function (action2) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n  obj = Object.assign({}, obj);\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n    }\n    return acc && acc[part];\n  }, obj);\n  return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject = item => {\n  return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n  if (!sources.length) return base;\n  const source = sources.shift();\n  if (isObject(base) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!base[key]) Object.assign(base, {\n          [key]: {}\n        });\n        mergeDeep(base[key], source[key]);\n      } else {\n        Object.assign(base, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(base, ...sources);\n};\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n  return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n  const allowedStatuses = [\"SUCCESSFUL\" /* Successful */, \"CANCELED\" /* Canceled */, \"ERRORED\" /* Errored */];\n\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n  return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\n\nfunction ofActionOperator(allowedTypes, statuses,\n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function (o) {\n    return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n  };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n  return filter(ctx => {\n    const actionType = getActionTypeFromInstance(ctx.action);\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\nfunction mapActionResult() {\n  return map(({\n    action,\n    status,\n    error\n  }) => {\n    return {\n      action,\n      result: {\n        successful: \"SUCCESSFUL\" /* Successful */ === status,\n        canceled: \"CANCELED\" /* Canceled */ === status,\n        error\n      }\n    };\n  });\n}\nfunction mapAction() {\n  return map(ctx => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n  return types.reduce((filterMap, klass) => {\n    filterMap[getActionTypeFromInstance(klass)] = true;\n    return filterMap;\n  }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n  return statuses.reduce((filterMap, status) => {\n    filterMap[status] = true;\n    return filterMap;\n  }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n  return source => {\n    return new Observable(sink => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n      });\n    });\n  };\n}\nclass InternalNgxsExecutionStrategy {\n  constructor(_executionStrategy) {\n    this._executionStrategy = _executionStrategy;\n  }\n  enter(func) {\n    return this._executionStrategy.enter(func);\n  }\n  leave(func) {\n    return this._executionStrategy.leave(func);\n  }\n}\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵfac = function InternalNgxsExecutionStrategy_Factory(t) {\n  return new (t || InternalNgxsExecutionStrategy)(i0.ɵɵinject(NGXS_EXECUTION_STRATEGY));\n};\n/** @nocollapse */\nInternalNgxsExecutionStrategy.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalNgxsExecutionStrategy,\n  factory: InternalNgxsExecutionStrategy.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalNgxsExecutionStrategy, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_EXECUTION_STRATEGY]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n  const callsQueue = [];\n  let busyPushingNext = false;\n  return function callOperation(...args) {\n    if (busyPushingNext) {\n      callsQueue.unshift(args);\n      return;\n    }\n    busyPushingNext = true;\n    operation(...args);\n    while (callsQueue.length > 0) {\n      const nextCallArgs = callsQueue.pop();\n      nextCallArgs && operation(...nextCallArgs);\n    }\n    busyPushingNext = false;\n  };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n  constructor() {\n    super(...arguments);\n    this.next = orderedQueueOperation(value => super.next(value));\n  }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedBehaviorSubject extends BehaviorSubject {\n  constructor() {\n    super(...arguments);\n    this.next = orderedQueueOperation(value => super.next(value));\n  }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n  ngOnDestroy() {\n    this.complete();\n  }\n}\n/** @nocollapse */\nInternalActions.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalActions_BaseFactory;\n  return function InternalActions_Factory(t) {\n    return (ɵInternalActions_BaseFactory || (ɵInternalActions_BaseFactory = i0.ɵɵgetInheritedFactory(InternalActions)))(t || InternalActions);\n  };\n}();\n/** @nocollapse */\nInternalActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalActions,\n  factory: InternalActions.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalActions, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n  constructor(internalActions$, internalExecutionStrategy) {\n    const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy),\n    // The `InternalActions` subject emits outside of the Angular zone.\n    // We have to re-enter the Angular zone for any incoming consumer.\n    // The `share()` operator reduces the number of change detections.\n    // This would call leave only once for any stream emission across all active subscribers.\n    share());\n    super(observer => {\n      const childSubscription = sharedInternalActions$.subscribe({\n        next: ctx => observer.next(ctx),\n        error: error => observer.error(error),\n        complete: () => observer.complete()\n      });\n      observer.add(childSubscription);\n    });\n  }\n}\n/** @nocollapse */\nActions.ɵfac = function Actions_Factory(t) {\n  return new (t || Actions)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalNgxsExecutionStrategy));\n};\n/** @nocollapse */\nActions.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Actions,\n  factory: Actions.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Actions, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }];\n  }, null);\n})();\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = funcs => (...args) => {\n  const curr = funcs.shift();\n  return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n  return source => {\n    let subscribed = false;\n    source.subscribe({\n      error: error => {\n        // Do not trigger change detection for a microtask. This depends on the execution\n        // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n        // leaves the Angular zone.\n        ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n          if (!subscribed) {\n            ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n          }\n        }));\n      }\n    });\n    return new Observable(subscriber => {\n      subscribed = true;\n      return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n    });\n  };\n}\nclass InternalErrorReporter {\n  constructor(_injector) {\n    this._injector = _injector;\n    /** Will be set lazily to be backward compatible. */\n    this._errorHandler = null;\n  }\n  reportErrorSafely(error) {\n    if (this._errorHandler === null) {\n      this._errorHandler = this._injector.get(ErrorHandler);\n    }\n    // The `try-catch` is used to avoid handling the error twice. Suppose we call\n    // `handleError` which re-throws the error internally. The re-thrown error will\n    // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n    // `onError` subscriber will call `handleError` again.\n    try {\n      this._errorHandler.handleError(error);\n    } catch (_a) {}\n  }\n}\n/** @nocollapse */\nInternalErrorReporter.ɵfac = function InternalErrorReporter_Factory(t) {\n  return new (t || InternalErrorReporter)(i0.ɵɵinject(i0.Injector));\n};\n/** @nocollapse */\nInternalErrorReporter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalErrorReporter,\n  factory: InternalErrorReporter.ɵfac,\n  providedIn: 'root'\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalErrorReporter, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends OrderedBehaviorSubject {\n  constructor() {\n    super({});\n  }\n  ngOnDestroy() {\n    // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n    // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n    // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n    this.complete();\n  }\n}\n/** @nocollapse */\nStateStream.ɵfac = function StateStream_Factory(t) {\n  return new (t || StateStream)();\n};\n/** @nocollapse */\nStateStream.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateStream,\n  factory: StateStream.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateStream, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\nclass PluginManager {\n  constructor(_parentManager, _pluginHandlers) {\n    this._parentManager = _parentManager;\n    this._pluginHandlers = _pluginHandlers;\n    this.plugins = [];\n    this.registerHandlers();\n  }\n  get rootPlugins() {\n    return this._parentManager && this._parentManager.plugins || this.plugins;\n  }\n  registerHandlers() {\n    const pluginHandlers = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n  getPluginHandlers() {\n    const handlers = this._pluginHandlers || [];\n    return handlers.map(plugin => plugin.handle ? plugin.handle.bind(plugin) : plugin);\n  }\n}\n/** @nocollapse */\nPluginManager.ɵfac = function PluginManager_Factory(t) {\n  return new (t || PluginManager)(i0.ɵɵinject(PluginManager, 12), i0.ɵɵinject(NGXS_PLUGINS, 8));\n};\n/** @nocollapse */\nPluginManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: PluginManager,\n  factory: PluginManager.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(PluginManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: PluginManager,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_PLUGINS]\n      }, {\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {}\n/** @nocollapse */\nInternalDispatchedActionResults.ɵfac = /* @__PURE__ */function () {\n  let ɵInternalDispatchedActionResults_BaseFactory;\n  return function InternalDispatchedActionResults_Factory(t) {\n    return (ɵInternalDispatchedActionResults_BaseFactory || (ɵInternalDispatchedActionResults_BaseFactory = i0.ɵɵgetInheritedFactory(InternalDispatchedActionResults)))(t || InternalDispatchedActionResults);\n  };\n}();\n/** @nocollapse */\nInternalDispatchedActionResults.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatchedActionResults,\n  factory: InternalDispatchedActionResults.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatchedActionResults, [{\n    type: Injectable\n  }], null, null);\n})();\nclass InternalDispatcher {\n  constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._pluginManager = _pluginManager;\n    this._stateStream = _stateStream;\n    this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n    this._internalErrorReporter = _internalErrorReporter;\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n    return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n  }\n  dispatchByEvents(actionOrActions) {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n  dispatchSingle(action) {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const type = getActionTypeFromInstance(action);\n      if (!type) {\n        const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n        return throwError(error);\n      }\n    }\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n    return compose([...plugins, (nextState, nextAction) => {\n      if (nextState !== prevState) {\n        this._stateStream.next(nextState);\n      }\n      const actionResult$ = this.getActionResultStream(nextAction);\n      actionResult$.subscribe(ctx => this._actions.next(ctx));\n      this._actions.next({\n        action: nextAction,\n        status: \"DISPATCHED\" /* Dispatched */\n      });\n      return this.createDispatchObservable(actionResult$);\n    }])(prevState, action).pipe(shareReplay());\n  }\n  getActionResultStream(action) {\n    return this._actionResults.pipe(filter(ctx => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n  }\n  createDispatchObservable(actionResult$) {\n    return actionResult$.pipe(exhaustMap(ctx => {\n      switch (ctx.status) {\n        case \"SUCCESSFUL\" /* Successful */:\n          return of(this._stateStream.getValue());\n        case \"ERRORED\" /* Errored */:\n          return throwError(ctx.error);\n        default:\n          return EMPTY;\n      }\n    })).pipe(shareReplay());\n  }\n}\n/** @nocollapse */\nInternalDispatcher.ɵfac = function InternalDispatcher_Factory(t) {\n  return new (t || InternalDispatcher)(i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(PluginManager), i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(InternalErrorReporter));\n};\n/** @nocollapse */\nInternalDispatcher.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalDispatcher,\n  factory: InternalDispatcher.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalDispatcher, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: PluginManager\n    }, {\n      type: StateStream\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: InternalErrorReporter\n    }];\n  }, null);\n})();\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = o => {\n  Object.freeze(o);\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n  Object.getOwnPropertyNames(o).forEach(function (prop) {\n    if (hasOwnProp.call(o, prop) && (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) && o[prop] !== null && (typeof o[prop] === 'object' || typeof o[prop] === 'function') && !Object.isFrozen(o[prop])) {\n      deepFreeze(o[prop]);\n    }\n  });\n  return o;\n};\n\n/**\n * State Context factory class\n * @ignore\n */\nclass InternalStateOperations {\n  constructor(_stateStream, _dispatcher, _config) {\n    this._stateStream = _stateStream;\n    this._dispatcher = _dispatcher;\n    this._config = _config;\n  }\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations() {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: newState => this._stateStream.next(newState),\n      dispatch: actionOrActions => this._dispatcher.dispatch(actionOrActions)\n    };\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      return this._config.developmentMode ? ensureStateAndActionsAreImmutable(rootStateOperations) : rootStateOperations;\n    } else {\n      return rootStateOperations;\n    }\n  }\n  setStateToTheCurrentWithNew(results) {\n    const stateOperations = this.getRootStateOperations();\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n  }\n}\n/** @nocollapse */\nInternalStateOperations.ɵfac = function InternalStateOperations_Factory(t) {\n  return new (t || InternalStateOperations)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalDispatcher), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nInternalStateOperations.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: InternalStateOperations,\n  factory: InternalStateOperations.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(InternalStateOperations, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalDispatcher\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\nfunction ensureStateAndActionsAreImmutable(root) {\n  return {\n    getState: () => root.getState(),\n    setState: value => {\n      const frozenValue = deepFreeze(value);\n      return root.setState(frozenValue);\n    },\n    dispatch: actions => {\n      return root.dispatch(actions);\n    }\n  };\n}\nfunction simplePatch(value) {\n  return existingState => {\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (Array.isArray(value)) {\n        throwPatchingArrayError();\n      } else if (typeof value !== 'object') {\n        throwPatchingPrimitiveError();\n      }\n    }\n    const newState = Object.assign({}, existingState);\n    for (const key in value) {\n      // deep clone for patch compatibility\n      newState[key] = value[key];\n    }\n    return newState;\n  };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n  constructor(_internalStateOperations) {\n    this._internalStateOperations = _internalStateOperations;\n  }\n  /**\n   * Create the state context\n   */\n  createStateContext(mappedStore) {\n    const root = this._internalStateOperations.getRootStateOperations();\n    function getState(currentAppState) {\n      return getValue(currentAppState, mappedStore.path);\n    }\n    function setStateValue(currentAppState, newValue) {\n      const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n      root.setState(newAppState);\n      return newAppState;\n      // In doing this refactoring I noticed that there is a 'bug' where the\n      // application state is returned instead of this state slice.\n      // This has worked this way since the beginning see:\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n      // This needs to be fixed, but is a 'breaking' change.\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\n    }\n\n    function setStateFromOperator(currentAppState, stateOperator) {\n      const local = getState(currentAppState);\n      const newValue = stateOperator(local);\n      return setStateValue(currentAppState, newValue);\n    }\n    function isStateOperator(value) {\n      return typeof value === 'function';\n    }\n    return {\n      getState() {\n        const currentAppState = root.getState();\n        return getState(currentAppState);\n      },\n      patchState(val) {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch(val);\n        return setStateFromOperator(currentAppState, patchOperator);\n      },\n      setState(val) {\n        const currentAppState = root.getState();\n        return isStateOperator(val) ? setStateFromOperator(currentAppState, val) : setStateValue(currentAppState, val);\n      },\n      dispatch(actions) {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n/** @nocollapse */\nStateContextFactory.ɵfac = function StateContextFactory_Factory(t) {\n  return new (t || StateContextFactory)(i0.ɵɵinject(InternalStateOperations));\n};\n/** @nocollapse */\nStateContextFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateContextFactory,\n  factory: StateContextFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateContextFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: InternalStateOperations\n    }];\n  }, null);\n})();\nclass StoreValidators {\n  static checkThatStateIsNamedCorrectly(name) {\n    if (!name) {\n      throwStateNamePropertyError();\n    } else if (!this.stateNameRegex.test(name)) {\n      throwStateNameError(name);\n    }\n  }\n  static checkThatStateNameIsUnique(stateName, state, statesByName) {\n    const existingState = statesByName[stateName];\n    if (existingState && existingState !== state) {\n      throwStateUniqueError(stateName, state.name, existingState.name);\n    }\n  }\n  static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n    stateClasses.forEach(stateClass => {\n      if (!getStoreMetadata$1(stateClass)) {\n        throwStateDecoratorError(stateClass.name);\n      }\n    });\n  }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n  // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  const ngInjectableDef = stateClass.ɵprov;\n  if (!ngInjectableDef) {\n    // Don't warn if Ivy is disabled or `ɵprov` exists on the class\n    console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n  }\n}\n\n/**\n * Init action\n */\nclass InitState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n}\n/**\n * Update action\n */\nclass UpdateState {\n  constructor(addedStates) {\n    this.addedStates = addedStates;\n  }\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n}\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n  providedIn: 'root',\n  factory: () => ({\n    warnOnUnhandledActions: true\n  })\n});\nclass NgxsUnhandledActionsLogger {\n  constructor(options) {\n    /**\n     * These actions should be ignored by default; the user can increase this\n     * list in the future via the `ignoreActions` method.\n     */\n    this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n    if (typeof options.warnOnUnhandledActions === 'object') {\n      this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n    }\n  }\n  /**\n   * Adds actions to the internal list of actions that should be ignored.\n   */\n  ignoreActions(...actions) {\n    for (const action of actions) {\n      this._ignoredActions.add(action.type);\n    }\n  }\n  /** @internal */\n  warn(action) {\n    const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n    if (actionShouldBeIgnored) {\n      return;\n    }\n    action = action.constructor && action.constructor.name !== 'Object' ? action.constructor.name : action.type;\n    console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n  }\n}\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵfac = function NgxsUnhandledActionsLogger_Factory(t) {\n  return new (t || NgxsUnhandledActionsLogger)(i0.ɵɵinject(NGXS_DEVELOPMENT_OPTIONS));\n};\n/** @nocollapse */\nNgxsUnhandledActionsLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NgxsUnhandledActionsLogger,\n  factory: NgxsUnhandledActionsLogger.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsUnhandledActionsLogger, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [NGXS_DEVELOPMENT_OPTIONS]\n      }]\n    }];\n  }, null);\n})();\n\n/**\n * State factory class\n * @ignore\n */\nclass StateFactory {\n  constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n    this._injector = _injector;\n    this._config = _config;\n    this._parentFactory = _parentFactory;\n    this._actions = _actions;\n    this._actionResults = _actionResults;\n    this._stateContextFactory = _stateContextFactory;\n    this._initialState = _initialState;\n    this._actionsSubscription = null;\n    this._states = [];\n    this._statesByName = {};\n    this._statePaths = {};\n    this.getRuntimeSelectorContext = memoize(() => {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const stateFactory = this;\n      function resolveGetter(key) {\n        const path = stateFactory.statePaths[key];\n        return path ? propGetter(path.split('.'), stateFactory._config) : null;\n      }\n      const context = this._parentFactory ? this._parentFactory.getRuntimeSelectorContext() : {\n        getStateGetter(key) {\n          let getter = resolveGetter(key);\n          if (getter) {\n            return getter;\n          }\n          return (...args) => {\n            // Late loaded getter\n            if (!getter) {\n              getter = resolveGetter(key);\n            }\n            return getter ? getter(...args) : undefined;\n          };\n        },\n        getSelectorOptions(localOptions) {\n          const globalSelectorOptions = stateFactory._config.selectorOptions;\n          return Object.assign(Object.assign({}, globalSelectorOptions), localOptions || {});\n        }\n      };\n      return context;\n    });\n  }\n  get states() {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n  get statesByName() {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n  get statePaths() {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n  static cloneDefaults(defaults) {\n    let value = {};\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (isObject$1(defaults)) {\n      value = Object.assign({}, defaults);\n    } else if (defaults === undefined) {\n      value = {};\n    } else {\n      value = defaults;\n    }\n    return value;\n  }\n  ngOnDestroy() {\n    // This is being non-null asserted since `_actionsSubscrition` is\n    // initialized within the constructor.\n    this._actionsSubscription.unsubscribe();\n  }\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses) {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n    }\n    const {\n      newStates\n    } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n    const stateGraph = buildGraph(newStates);\n    const sortedStates = topologicalSort(stateGraph);\n    const paths = findFullParentPath(stateGraph);\n    const nameGraph = nameToState(newStates);\n    const bootstrappedStores = [];\n    for (const name of sortedStates) {\n      const stateClass = nameGraph[name];\n      const path = paths[name];\n      const meta = stateClass[META_KEY];\n      this.addRuntimeInfoToMeta(meta, path);\n      // Note: previously we called `ensureStateClassIsInjectable` within the\n      // `State` decorator. This check is moved here because the `ɵprov` property\n      // will not exist on the class in JIT mode (because it's set asynchronously\n      // during JIT compilation through `Object.defineProperty`).\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        ensureStateClassIsInjectable(stateClass);\n      }\n      const stateMap = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: StateFactory.cloneDefaults(meta.defaults)\n      };\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n      this.states.push(stateMap);\n    }\n    return bootstrappedStores;\n  }\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses) {\n    const classes = stateClasses || [];\n    const mappedStores = this.add(classes);\n    const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n    return {\n      defaults,\n      states: mappedStores\n    };\n  }\n  /**\n   * Bind the actions to the handlers\n   */\n  connectActionHandlers() {\n    if (this._actionsSubscription !== null) return;\n    const dispatched$ = new Subject();\n    this._actionsSubscription = this._actions.pipe(filter(ctx => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n      dispatched$.next(ctx);\n      const action = ctx.action;\n      return this.invokeActions(dispatched$, action).pipe(map(() => ({\n        action,\n        status: \"SUCCESSFUL\" /* Successful */\n      })), defaultIfEmpty({\n        action,\n        status: \"CANCELED\" /* Canceled */\n      }), catchError(error => of({\n        action,\n        status: \"ERRORED\" /* Errored */,\n        error\n      })));\n    })).subscribe(ctx => this._actionResults.next(ctx));\n  }\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(dispatched$, action) {\n    const type = getActionTypeFromInstance(action);\n    const results = [];\n    // Determines whether the dispatched action has been handled, this is assigned\n    // to `true` within the below `for` loop if any `actionMetas` has been found.\n    let actionHasBeenHandled = false;\n    for (const metadata of this.states) {\n      const actionMetas = metadata.actions[type];\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n            if (isObservable(result)) {\n              // If this observable has been completed w/o emitting\n              // any value then we wouldn't want to complete the whole chain\n              // of actions. Since if any observable completes then\n              // action will be canceled.\n              // For instance if any action handler would've had such statement:\n              // `handler(ctx) { return EMPTY; }`\n              // then the action will be canceled.\n              // See https://github.com/ngxs/store/issues/1568\n              result = result.pipe(mergeMap(value => {\n                if (value instanceof Promise) {\n                  return from(value);\n                }\n                if (isObservable(value)) {\n                  return value;\n                }\n                return of(value);\n              }), defaultIfEmpty({}));\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n          actionHasBeenHandled = true;\n        }\n      }\n    }\n    // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n    // only during development.\n    if ((typeof ngDevMode === 'undefined' || ngDevMode) && !actionHasBeenHandled) {\n      const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n      // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n      // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n      // didn't return `null` so we may ensure the module has been imported.\n      if (unhandledActionsLogger) {\n        unhandledActionsLogger.warn(action);\n      }\n    }\n    if (!results.length) {\n      results.push(of({}));\n    }\n    return forkJoin(results);\n  }\n  addToStatesMap(stateClasses) {\n    const newStates = [];\n    const statesMap = this.statesByName;\n    for (const stateClass of stateClasses) {\n      const stateName = getStoreMetadata$1(stateClass).name;\n      // Caretaker note: we have still left the `typeof` condition in order to avoid\n      // creating a breaking change for projects that still use the View Engine.\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n      }\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n    return {\n      newStates\n    };\n  }\n  addRuntimeInfoToMeta(meta, path) {\n    this.statePaths[meta.name] = path;\n    // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative in v4 because this is used by many plugins\n    meta.path = path;\n  }\n  /**\n   * @description\n   * the method checks if the state has already been added to the tree\n   * and completed the life cycle\n   * @param name\n   * @param path\n   */\n  hasBeenMountedAndBootstrapped(name, path) {\n    const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n}\n/** @nocollapse */\nStateFactory.ɵfac = function StateFactory_Factory(t) {\n  return new (t || StateFactory)(i0.ɵɵinject(i0.Injector), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(StateFactory, 12), i0.ɵɵinject(InternalActions), i0.ɵɵinject(InternalDispatchedActionResults), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStateFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: StateFactory,\n  factory: StateFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StateFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }, {\n      type: NgxsConfig\n    }, {\n      type: StateFactory,\n      decorators: [{\n        type: Optional\n      }, {\n        type: SkipSelf\n      }]\n    }, {\n      type: InternalActions\n    }, {\n      type: InternalDispatchedActionResults\n    }, {\n      type: StateContextFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n  return context => {\n    const {\n      argumentSelectorFunctions,\n      selectorOptions\n    } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n    return function selectFromRoot(rootState) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n      // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n      try {\n        return memoizedSelectorFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n        throw ex;\n      }\n    };\n  };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  };\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n  return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n  const selectorsToApply = [];\n  const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata$1(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n  return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  return metadata && metadata.makeRootSelector || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n  constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n    this._stateStream = _stateStream;\n    this._internalStateOperations = _internalStateOperations;\n    this._config = _config;\n    this._internalExecutionStrategy = _internalExecutionStrategy;\n    this._stateFactory = _stateFactory;\n    /**\n     * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n     * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n     * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n     */\n    this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n    this.initStateStream(initialStateValue);\n  }\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions) {\n    return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n  }\n  select(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._selectableStateStream.pipe(map(selectorFn), catchError(err => {\n      // if error is TypeError we swallow it to prevent usual errors with property access\n      const {\n        suppressErrors\n      } = this._config.selectorOptions;\n      if (err instanceof TypeError && suppressErrors) {\n        return of(undefined);\n      }\n      // rethrow other errors\n      return throwError(err);\n    }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n  }\n  selectOnce(selector) {\n    return this.select(selector).pipe(take(1));\n  }\n  selectSnapshot(selector) {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn) {\n    return this._selectableStateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot() {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n  getStoreBoundSelectorFn(selector) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n  initStateStream(initialStateValue) {\n    const value = this._stateStream.value;\n    const storeIsEmpty = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n      const storeValues = defaultStateNotEmpty ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n      this._stateStream.next(storeValues);\n    }\n  }\n}\n/** @nocollapse */\nStore.ɵfac = function Store_Factory(t) {\n  return new (t || Store)(i0.ɵɵinject(StateStream), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(NgxsConfig), i0.ɵɵinject(InternalNgxsExecutionStrategy), i0.ɵɵinject(StateFactory), i0.ɵɵinject(INITIAL_STATE_TOKEN, 8));\n};\n/** @nocollapse */\nStore.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: Store,\n  factory: Store.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(Store, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: StateStream\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: NgxsConfig\n    }, {\n      type: InternalNgxsExecutionStrategy\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [INITIAL_STATE_TOKEN]\n      }]\n    }];\n  }, null);\n})();\nclass LifecycleStateManager {\n  constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n    this._store = _store;\n    this._internalErrorReporter = _internalErrorReporter;\n    this._internalStateOperations = _internalStateOperations;\n    this._stateContextFactory = _stateContextFactory;\n    this._bootstrapper = _bootstrapper;\n    this._destroy$ = new Subject();\n  }\n  ngOnDestroy() {\n    this._destroy$.next();\n  }\n  ngxsBootstrap(action, results) {\n    this._internalStateOperations.getRootStateOperations().dispatch(action).pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n      // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n      // errors asynchronously (`setTimeout(() => { throw error })`). This might\n      // break existing user's code or unit tests. We catch the error manually to\n      // be backward compatible with the old behavior.\n      this._internalErrorReporter.reportErrorSafely(error);\n      return EMPTY;\n    }), takeUntil(this._destroy$)).subscribe(() => this._invokeBootstrapOnStates(results.states));\n  }\n  _invokeInitOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsOnChanges) {\n        this._store.select(state => getValue(state, mappedStore.path)).pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$)).subscribe(([previousValue, currentValue]) => {\n          const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n          instance.ngxsOnChanges(change);\n        });\n      }\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this._getStateContext(mappedStore));\n      }\n      mappedStore.isInitialised = true;\n    }\n  }\n  _invokeBootstrapOnStates(mappedStores) {\n    for (const mappedStore of mappedStores) {\n      const instance = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n      }\n    }\n  }\n  _getStateContext(mappedStore) {\n    return this._stateContextFactory.createStateContext(mappedStore);\n  }\n}\n/** @nocollapse */\nLifecycleStateManager.ɵfac = function LifecycleStateManager_Factory(t) {\n  return new (t || LifecycleStateManager)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalErrorReporter), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateContextFactory), i0.ɵɵinject(i5.NgxsBootstrapper));\n};\n/** @nocollapse */\nLifecycleStateManager.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LifecycleStateManager,\n  factory: LifecycleStateManager.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LifecycleStateManager, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalErrorReporter\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateContextFactory\n    }, {\n      type: i5.NgxsBootstrapper\n    }];\n  }, null);\n})();\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n  constructor(store, config) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n  ngOnDestroy() {\n    SelectFactory.store = null;\n    SelectFactory.config = null;\n  }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */\nSelectFactory.ɵfac = function SelectFactory_Factory(t) {\n  return new (t || SelectFactory)(i0.ɵɵinject(Store), i0.ɵɵinject(NgxsConfig));\n};\n/** @nocollapse */\nSelectFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: SelectFactory,\n  factory: SelectFactory.ɵfac\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(SelectFactory, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: NgxsConfig\n    }];\n  }, null);\n})();\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n  constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n    // Add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(states);\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n    // Connect our actions stream\n    factory.connectActionHandlers();\n    // Dispatch the init action and invoke init and bootstrap functions after\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n  }\n}\n/** @nocollapse */\nNgxsRootModule.ɵfac = function NgxsRootModule_Factory(t) {\n  return new (t || NgxsRootModule)(i0.ɵɵinject(StateFactory), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(Store), i0.ɵɵinject(SelectFactory), i0.ɵɵinject(ROOT_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsRootModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsRootModule\n});\n/** @nocollapse */\nNgxsRootModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsRootModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: StateFactory\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: Store\n    }, {\n      type: SelectFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [ROOT_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n  constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates = NgxsFeatureModule.flattenStates(states);\n    // add stores to the state graph and return their defaults\n    const results = factory.addAndReturnDefaults(flattenedStates);\n    if (results.states.length) {\n      internalStateOperations.setStateToTheCurrentWithNew(results);\n      // dispatch the update action and invoke init and bootstrap functions after\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n  }\n  static flattenStates(states = []) {\n    return states.reduce((total, values) => total.concat(values), []);\n  }\n}\n/** @nocollapse */\nNgxsFeatureModule.ɵfac = function NgxsFeatureModule_Factory(t) {\n  return new (t || NgxsFeatureModule)(i0.ɵɵinject(Store), i0.ɵɵinject(InternalStateOperations), i0.ɵɵinject(StateFactory), i0.ɵɵinject(FEATURE_STATE_TOKEN, 8), i0.ɵɵinject(LifecycleStateManager));\n};\n/** @nocollapse */\nNgxsFeatureModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsFeatureModule\n});\n/** @nocollapse */\nNgxsFeatureModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsFeatureModule, [{\n    type: NgModule\n  }], function () {\n    return [{\n      type: Store\n    }, {\n      type: InternalStateOperations\n    }, {\n      type: StateFactory\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Optional\n      }, {\n        type: Inject,\n        args: [FEATURE_STATE_TOKEN]\n      }]\n    }, {\n      type: LifecycleStateManager\n    }];\n  }, null);\n})();\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n  /**\n   * Root module factory\n   */\n  static forRoot(states = [], options = {}) {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [StateFactory, StateContextFactory, Actions, InternalActions, NgxsBootstrapper, LifecycleStateManager, InternalDispatcher, InternalDispatchedActionResults, InternalStateOperations, InternalNgxsExecutionStrategy, Store, StateStream, SelectFactory, PluginManager, ...states, ...NgxsModule.ngxsTokenProviders(states, options)]\n    };\n  }\n  /**\n   * Feature module factory\n   */\n  static forFeature(states = []) {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [StateFactory, PluginManager, ...states, {\n        provide: FEATURE_STATE_TOKEN,\n        multi: true,\n        useValue: states\n      }]\n    };\n  }\n  static ngxsTokenProviders(states, options) {\n    return [{\n      provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n      useValue: options.executionStrategy\n    }, {\n      provide: ROOT_STATE_TOKEN,\n      useValue: states\n    }, {\n      provide: NgxsModule.ROOT_OPTIONS,\n      useValue: options\n    }, {\n      provide: NgxsConfig,\n      useFactory: NgxsModule.ngxsConfigFactory,\n      deps: [NgxsModule.ROOT_OPTIONS]\n    }, {\n      provide: APP_BOOTSTRAP_LISTENER,\n      useFactory: NgxsModule.appBootstrapListenerFactory,\n      multi: true,\n      deps: [NgxsBootstrapper]\n    }, {\n      provide: INITIAL_STATE_TOKEN,\n      useFactory: NgxsModule.getInitialState\n    }, {\n      provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n      useExisting: StateContextFactory\n    }, {\n      provide: ɵNGXS_STATE_FACTORY,\n      useExisting: StateFactory\n    }];\n  }\n  static ngxsConfigFactory(options) {\n    return mergeDeep(new NgxsConfig(), options);\n  }\n  static appBootstrapListenerFactory(bootstrapper) {\n    return () => bootstrapper.bootstrap();\n  }\n  static getInitialState() {\n    return InitialState.pop();\n  }\n}\nNgxsModule.ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n/** @nocollapse */\nNgxsModule.ɵfac = function NgxsModule_Factory(t) {\n  return new (t || NgxsModule)();\n};\n/** @nocollapse */\nNgxsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsModule\n});\n/** @nocollapse */\nNgxsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsModule, [{\n    type: NgModule\n  }], null, null);\n})();\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n  return (target, name) => {\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      const isStaticMethod = target.hasOwnProperty('prototype');\n      if (isStaticMethod) {\n        throwActionDecoratorError();\n      }\n    }\n    const meta = ensureStoreMetadata$1(target.constructor);\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n    for (const action of actions) {\n      const type = action.type;\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n  function getStateOptions(inheritedStateClass) {\n    const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n    return Object.assign(Object.assign({}, inheritanceOptions), options);\n  }\n  function mutateMetaData(params) {\n    const {\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    } = params;\n    const {\n      children,\n      defaults,\n      name\n    } = optionsWithInheritance;\n    const stateName = typeof name === 'string' ? name : name && name.getName() || null;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n    }\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      const inheritedMeta = inheritedStateClass[META_KEY] || {};\n      meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n    }\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n  return target => {\n    const stateClass = target;\n    const meta = ensureStoreMetadata$1(stateClass);\n    const inheritedStateClass = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance = getStateOptions(inheritedStateClass);\n    mutateMetaData({\n      meta,\n      inheritedStateClass,\n      optionsWithInheritance\n    });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n  if (!SelectFactory.store) {\n    throwSelectFactoryNotConnectedError();\n  }\n  return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n  if (typeof rawSelector === 'string') {\n    const propsArray = paths.length ? [rawSelector, ...paths] : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config);\n  }\n  return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n  const lastCharIndex = name.length - 1;\n  const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n  return function (target, key) {\n    const name = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n  getOptions: target => {\n    return target && target[SELECTOR_OPTIONS_META_KEY] || {};\n  },\n  defineOptions: (target, options) => {\n    if (!target) return;\n    target[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n  const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName || null;\n    getExplicitSelectorOptions = creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n  selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n  return Object.assign(Object.assign(Object.assign(Object.assign({}, selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}), selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}), selectorMetaData.getSelectorOptions() || {}), explicitOptions);\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n  return function decorate(target, methodName, descriptor) {\n    if (methodName) {\n      descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n      // Method Decorator\n      const originalFn = descriptor.value || descriptor.originalFn;\n      if (originalFn) {\n        selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n      }\n    } else {\n      // Class Decorator\n      selectorOptionsMetaAccessor.defineOptions(target, options);\n    }\n  };\n}\nfunction ensureStoreMetadata(target) {\n  return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n  return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n  return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n  return getSelectorMetadata$1(target);\n}\nfunction createSelector(selectors, projector, creationMetadata) {\n  const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n  const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n  selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n  return memoizedFn;\n}\nfunction Selector(selectors) {\n  return (target, key, descriptor) => {\n    descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n    const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n    // Caretaker note: we have still left the `typeof` condition in order to avoid\n    // creating a breaking change for projects that still use the View Engine.\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n      if (originalFn && typeof originalFn !== 'function') {\n        throwSelectorDecoratorError();\n      }\n    }\n    const memoizedFn = createSelector(selectors, originalFn, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      }\n    };\n    // Add hidden property to descriptor\n    newDescriptor['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\nclass StateToken {\n  constructor(name) {\n    this.name = name;\n    const selectorMetadata = ensureSelectorMetadata$1(this);\n    selectorMetadata.makeRootSelector = runtimeContext => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n  getName() {\n    return this.name;\n  }\n  toString() {\n    return `StateToken[${this.name}]`;\n  }\n}\nclass NgxsDevelopmentModule {\n  static forRoot(options) {\n    return {\n      ngModule: NgxsDevelopmentModule,\n      providers: [NgxsUnhandledActionsLogger, {\n        provide: NGXS_DEVELOPMENT_OPTIONS,\n        useValue: options\n      }]\n    };\n  }\n}\n/** @nocollapse */\nNgxsDevelopmentModule.ɵfac = function NgxsDevelopmentModule_Factory(t) {\n  return new (t || NgxsDevelopmentModule)();\n};\n/** @nocollapse */\nNgxsDevelopmentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxsDevelopmentModule\n});\n/** @nocollapse */\nNgxsDevelopmentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxsDevelopmentModule, [{\n    type: NgModule\n  }], null, null);\n})();\nfunction ensureValidSelector(selector, context = {}) {\n  const noun = context.noun || 'selector';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  ensureValueProvided(selector, {\n    noun,\n    prefix: context.prefix\n  });\n  const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n  if (!metadata) {\n    throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n  }\n}\nfunction ensureValueProvided(value, context = {}) {\n  const noun = context.noun || 'value';\n  const prefix = context.prefix ? context.prefix + ': ' : '';\n  if (!value) {\n    throw new Error(`${prefix}A ${noun} must be provided.`);\n  }\n}\nfunction createModelSelector(selectorMap) {\n  const selectorKeys = Object.keys(selectorMap);\n  const selectors = Object.values(selectorMap);\n  ensureValidSelectorMap({\n    prefix: '[createModelSelector]',\n    selectorMap,\n    selectorKeys,\n    selectors\n  });\n  return createSelector(selectors, (...args) => {\n    return selectorKeys.reduce((obj, key, index) => {\n      obj[key] = args[index];\n      return obj;\n    }, {});\n  });\n}\nfunction ensureValidSelectorMap({\n  prefix,\n  selectorMap,\n  selectorKeys,\n  selectors\n}) {\n  ensureValueProvided(selectorMap, {\n    prefix,\n    noun: 'selector map'\n  });\n  ensureValueProvided(typeof selectorMap === 'object', {\n    prefix,\n    noun: 'valid selector map'\n  });\n  ensureValueProvided(selectorKeys.length, {\n    prefix,\n    noun: 'non-empty selector map'\n  });\n  selectors.forEach((selector, index) => ensureValidSelector(selector, {\n    prefix,\n    noun: `selector for the '${selectorKeys[index]}' property`\n  }));\n}\nfunction createPickSelector(selector, keys) {\n  ensureValidSelector(selector, {\n    prefix: '[createPickSelector]'\n  });\n  const validKeys = keys.filter(Boolean);\n  const selectors = validKeys.map(key => createSelector([selector], s => s[key]));\n  return createSelector([...selectors], (...props) => {\n    return validKeys.reduce((acc, key, index) => {\n      acc[key] = props[index];\n      return acc;\n    }, {});\n  });\n}\nfunction createPropertySelectors(parentSelector) {\n  ensureValidSelector(parentSelector, {\n    prefix: '[createPropertySelectors]',\n    noun: 'parent selector'\n  });\n  const cache = {};\n  return new Proxy({}, {\n    get(_target, prop) {\n      const selector = cache[prop] || createSelector([parentSelector], s => s === null || s === void 0 ? void 0 : s[prop]);\n      cache[prop] = selector;\n      return selector;\n    }\n  });\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };","map":{"version":3,"names":["i0","NgZone","PLATFORM_ID","Injectable","Inject","InjectionToken","inject","INJECTOR","ɵglobal","ErrorHandler","Optional","SkipSelf","NgModule","APP_BOOTSTRAP_LISTENER","i5","memoize","INITIAL_STATE_TOKEN","NgxsBootstrapper","ɵNGXS_STATE_CONTEXT_FACTORY","ɵNGXS_STATE_FACTORY","InitialState","isPlatformServer","Observable","Subject","BehaviorSubject","of","forkJoin","throwError","EMPTY","from","isObservable","filter","map","share","shareReplay","take","exhaustMap","mergeMap","defaultIfEmpty","catchError","takeUntil","distinctUntilChanged","tap","startWith","pairwise","throwStateNameError","name","Error","throwStateNamePropertyError","throwStateUniqueError","current","newName","oldName","throwStateDecoratorError","throwActionDecoratorError","throwSelectorDecoratorError","getZoneWarningMessage","getUndecoratedStateInIvyWarningMessage","throwSelectFactoryNotConnectedError","throwPatchingArrayError","throwPatchingPrimitiveError","DispatchOutsideZoneNgxsExecutionStrategy","constructor","_ngZone","_platformId","ngDevMode","verifyZoneIsNotNooped","enter","func","runInsideAngular","runOutsideAngular","leave","isInAngularZone","run","ɵfac","DispatchOutsideZoneNgxsExecutionStrategy_Factory","t","ɵɵinject","ɵprov","ɵɵdefineInjectable","token","factory","providedIn","ɵsetClassMetadata","type","args","undefined","decorators","ngZone","console","warn","ROOT_STATE_TOKEN","FEATURE_STATE_TOKEN","NGXS_PLUGINS","META_KEY","META_OPTIONS_KEY","SELECTOR_META_KEY","NgxsConfig","defaultsState","selectorOptions","injectContainerState","suppressErrors","compatibility","strictContentSecurityPolicy","executionStrategy","NgxsConfig_Factory","NgxsSimpleChange","previousValue","currentValue","firstChange","NoopNgxsExecutionStrategy","NoopNgxsExecutionStrategy_Factory","USER_PROVIDED_NGXS_EXECUTION_STRATEGY","NGXS_EXECUTION_STRATEGY","injector","get","Zone","ensureStoreMetadata$1","target","hasOwnProperty","defaultMetadata","actions","defaults","path","makeRootSelector","context","getStateGetter","children","Object","defineProperty","value","getStoreMetadata$1","ensureSelectorMetadata$1","originalFn","containerClass","selectorName","getSelectorOptions","getSelectorMetadata$1","compliantPropGetter","paths","copyOfPaths","slice","obj","reduce","acc","part","fastPropGetter","segments","seg","i","l","length","expr","fn","Function","propGetter","config","buildGraph","stateClasses","findName","stateClass","meta","find","g","result","nameToState","states","findFullParentPath","newObj","visit","child","keyToFind","key","indexOf","parent","topologicalSort","graph","sorted","visited","ancestors","Array","isArray","push","forEach","dep","join","keys","k","reverse","isObject$1","getActionTypeFromInstance","action","actionMatcher","action1","type1","action2","setValue","prop","val","assign","split","lastIndex","index","getValue","isObject","item","mergeDeep","base","sources","source","shift","ofAction","allowedTypes","ofActionOperator","ofActionDispatched","ofActionSuccessful","ofActionCanceled","ofActionCompleted","allowedStatuses","mapActionResult","ofActionErrored","statuses","mapOperator","mapAction","allowedMap","createAllowedActionTypesMap","allowedStatusMap","createAllowedStatusesMap","o","pipe","filterStatus","ctx","actionType","typeMatch","statusMatch","status","error","successful","canceled","types","filterMap","klass","leaveNgxs","ngxsExecutionStrategy","sink","subscribe","next","complete","InternalNgxsExecutionStrategy","_executionStrategy","InternalNgxsExecutionStrategy_Factory","orderedQueueOperation","operation","callsQueue","busyPushingNext","callOperation","unshift","nextCallArgs","pop","OrderedSubject","arguments","OrderedBehaviorSubject","InternalActions","ngOnDestroy","ɵInternalActions_BaseFactory","InternalActions_Factory","ɵɵgetInheritedFactory","Actions","internalActions$","internalExecutionStrategy","sharedInternalActions$","observer","childSubscription","add","Actions_Factory","compose","funcs","curr","nextArgs","ngxsErrorHandler","internalErrorReporter","subscribed","Promise","resolve","then","reportErrorSafely","subscriber","InternalErrorReporter","_injector","_errorHandler","handleError","_a","InternalErrorReporter_Factory","Injector","StateStream","StateStream_Factory","PluginManager","_parentManager","_pluginHandlers","plugins","registerHandlers","rootPlugins","pluginHandlers","getPluginHandlers","handlers","plugin","handle","bind","PluginManager_Factory","InternalDispatchedActionResults","ɵInternalDispatchedActionResults_BaseFactory","InternalDispatchedActionResults_Factory","InternalDispatcher","_actions","_actionResults","_pluginManager","_stateStream","_ngxsExecutionStrategy","_internalErrorReporter","dispatch","actionOrActions","dispatchByEvents","dispatchSingle","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","InternalDispatcher_Factory","deepFreeze","freeze","oIsFunction","hasOwnProp","prototype","getOwnPropertyNames","call","isFrozen","InternalStateOperations","_dispatcher","_config","getRootStateOperations","rootStateOperations","getState","setState","newState","developmentMode","ensureStateAndActionsAreImmutable","setStateToTheCurrentWithNew","results","stateOperations","currentState","InternalStateOperations_Factory","root","frozenValue","simplePatch","existingState","StateContextFactory","_internalStateOperations","createStateContext","mappedStore","currentAppState","setStateValue","newValue","newAppState","setStateFromOperator","stateOperator","local","isStateOperator","patchState","patchOperator","StateContextFactory_Factory","StoreValidators","checkThatStateIsNamedCorrectly","stateNameRegex","test","checkThatStateNameIsUnique","stateName","state","statesByName","checkThatStateClassesHaveBeenDecorated","RegExp","ensureStateClassIsInjectable","ngInjectableDef","InitState","UpdateState","addedStates","NGXS_DEVELOPMENT_OPTIONS","warnOnUnhandledActions","NgxsUnhandledActionsLogger","options","_ignoredActions","Set","ignoreActions","ignore","actionShouldBeIgnored","some","NgxsUnhandledActionsLogger_Factory","StateFactory","_parentFactory","_stateContextFactory","_initialState","_actionsSubscription","_states","_statesByName","_statePaths","getRuntimeSelectorContext","stateFactory","resolveGetter","statePaths","getter","localOptions","globalSelectorOptions","cloneDefaults","unsubscribe","newStates","addToStatesMap","stateGraph","sortedStates","nameGraph","bootstrappedStores","addRuntimeInfoToMeta","stateMap","isInitialised","instance","hasBeenMountedAndBootstrapped","addAndReturnDefaults","classes","mappedStores","connectActionHandlers","dispatched$","invokeActions","actionHasBeenHandled","metadata","actionMetas","actionMeta","stateContext","cancelUncompleted","e","unhandledActionsLogger","statesMap","unmountedState","valueIsBootstrappedInInitialState","StateFactory_Factory","createRootSelectorFactory","selectorMetaData","selectors","memoizedSelectorFn","argumentSelectorFunctions","getRuntimeSelectorInfo","selectFromRoot","rootState","argFn","ex","TypeError","createMemoizedSelectorFn","creationMetadata","wrappedFn","wrappedSelectorFn","returnValue","apply","innerMemoizedFn","memoizedFn","setPrototypeOf","localSelectorOptions","selectorsToApply","getSelectorsToApply","selector","getRootSelectorFactory","canInjectContainerState","Store","_internalExecutionStrategy","_stateFactory","initialStateValue","_selectableStateStream","bufferSize","refCount","initStateStream","select","selectorFn","getStoreBoundSelectorFn","err","selectOnce","selectSnapshot","snapshot","reset","makeSelectorFn","runtimeContext","storeIsEmpty","defaultStateNotEmpty","storeValues","Store_Factory","LifecycleStateManager","_store","_bootstrapper","_destroy$","ngxsBootstrap","_invokeInitOnStates","appBootstrapped$","appBootstrapped","_invokeBootstrapOnStates","ngxsOnChanges","change","ngxsOnInit","_getStateContext","ngxsAfterBootstrap","LifecycleStateManager_Factory","SelectFactory","store","SelectFactory_Factory","NgxsRootModule","internalStateOperations","_select","lifecycleStateManager","NgxsRootModule_Factory","ɵmod","ɵɵdefineNgModule","ɵinj","ɵɵdefineInjector","NgxsFeatureModule","flattenedStates","flattenStates","total","values","concat","NgxsFeatureModule_Factory","NgxsModule","forRoot","ngModule","providers","ngxsTokenProviders","forFeature","provide","multi","useValue","ROOT_OPTIONS","useFactory","ngxsConfigFactory","deps","appBootstrapListenerFactory","getInitialState","useExisting","bootstrapper","bootstrap","NgxsModule_Factory","Action","isStaticMethod","State","getStateOptions","inheritedStateClass","inheritanceOptions","mutateMetaData","params","optionsWithInheritance","getName","inheritedMeta","getPrototypeOf","DOLLAR_CHAR_CODE","createSelectObservable","createSelectorFn","rawSelector","removeDollarAtTheEnd","propsArray","lastCharIndex","dollarAtTheEnd","charCodeAt","Select","toString","selectorId","defineProperties","writable","enumerable","configurable","SELECTOR_OPTIONS_META_KEY","selectorOptionsMetaAccessor","getOptions","defineOptions","setupSelectorMetadata","getExplicitSelectorOptions","selectorMetaDataClone","getLocalSelectorOptions","explicitOptions","SelectorOptions","decorate","methodName","descriptor","getOwnPropertyDescriptor","ensureStoreMetadata","getStoreMetadata","ensureSelectorMetadata","getSelectorMetadata","createSelector","projector","Selector","newDescriptor","StateToken","selectorMetadata","NgxsDevelopmentModule","NgxsDevelopmentModule_Factory","ensureValidSelector","noun","prefix","ensureValueProvided","createModelSelector","selectorMap","selectorKeys","ensureValidSelectorMap","createPickSelector","validKeys","Boolean","s","props","createPropertySelectors","parentSelector","cache","Proxy","_target","ɵNgxsFeatureModule","ɵNgxsRootModule"],"sources":["C:/Users/paddy/Documents/GitHub/pet_feeder_ui/pet-minder-ui/node_modules/@ngxs/store/fesm2015/ngxs-store.js"],"sourcesContent":["import * as i0 from '@angular/core';\nimport { NgZone, PLATFORM_ID, Injectable, Inject, InjectionToken, inject, INJECTOR, ɵglobal, ErrorHandler, Optional, SkipSelf, NgModule, APP_BOOTSTRAP_LISTENER } from '@angular/core';\nimport * as i5 from '@ngxs/store/internals';\nimport { memoize, INITIAL_STATE_TOKEN, NgxsBootstrapper, ɵNGXS_STATE_CONTEXT_FACTORY, ɵNGXS_STATE_FACTORY, InitialState } from '@ngxs/store/internals';\nimport { isPlatformServer } from '@angular/common';\nimport { Observable, Subject, BehaviorSubject, of, forkJoin, throwError, EMPTY, from, isObservable } from 'rxjs';\nimport { filter, map, share, shareReplay, take, exhaustMap, mergeMap, defaultIfEmpty, catchError, takeUntil, distinctUntilChanged, tap, startWith, pairwise } from 'rxjs/operators';\n\nfunction throwStateNameError(name) {\n    throw new Error(`${name} is not a valid state name. It needs to be a valid object property name.`);\n}\nfunction throwStateNamePropertyError() {\n    throw new Error(`States must register a 'name' property.`);\n}\nfunction throwStateUniqueError(current, newName, oldName) {\n    throw new Error(`State name '${current}' from ${newName} already exists in ${oldName}.`);\n}\nfunction throwStateDecoratorError(name) {\n    throw new Error(`States must be decorated with @State() decorator, but \"${name}\" isn't.`);\n}\nfunction throwActionDecoratorError() {\n    throw new Error('@Action() decorator cannot be used with static methods.');\n}\nfunction throwSelectorDecoratorError() {\n    throw new Error('Selectors only work on methods.');\n}\nfunction getZoneWarningMessage() {\n    return ('Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' +\n        'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' +\n        'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })');\n}\nfunction getUndecoratedStateInIvyWarningMessage(name) {\n    return `'${name}' class should be decorated with @Injectable() right after the @State() decorator`;\n}\nfunction throwSelectFactoryNotConnectedError() {\n    throw new Error('You have forgotten to import the NGXS module!');\n}\nfunction throwPatchingArrayError() {\n    throw new Error('Patching arrays is not supported.');\n}\nfunction throwPatchingPrimitiveError() {\n    throw new Error('Patching primitives is not supported.');\n}\n\nclass DispatchOutsideZoneNgxsExecutionStrategy {\n    constructor(_ngZone, _platformId) {\n        this._ngZone = _ngZone;\n        this._platformId = _platformId;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            verifyZoneIsNotNooped(_ngZone);\n        }\n    }\n    enter(func) {\n        if (isPlatformServer(this._platformId)) {\n            return this.runInsideAngular(func);\n        }\n        return this.runOutsideAngular(func);\n    }\n    leave(func) {\n        return this.runInsideAngular(func);\n    }\n    runInsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return func();\n        }\n        return this._ngZone.run(func);\n    }\n    runOutsideAngular(func) {\n        if (NgZone.isInAngularZone()) {\n            return this._ngZone.runOutsideAngular(func);\n        }\n        return func();\n    }\n}\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, deps: [{ token: i0.NgZone }, { token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ DispatchOutsideZoneNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: DispatchOutsideZoneNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.NgZone }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [PLATFORM_ID]\n                }] }]; } });\n// Caretaker note: this should exist as a separate function and not a class method,\n// since class methods are not tree-shakable.\nfunction verifyZoneIsNotNooped(ngZone) {\n    // `NoopNgZone` is not exposed publicly as it doesn't expect\n    // to be used outside of the core Angular code, thus we just have\n    // to check if the zone doesn't extend or instanceof `NgZone`.\n    if (ngZone instanceof NgZone) {\n        return;\n    }\n    console.warn(getZoneWarningMessage());\n}\n\nconst ROOT_STATE_TOKEN = new InjectionToken('ROOT_STATE_TOKEN');\nconst FEATURE_STATE_TOKEN = new InjectionToken('FEATURE_STATE_TOKEN');\nconst NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nconst META_KEY = 'NGXS_META';\nconst META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nconst SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n/**\n * The NGXS config settings.\n */\nclass NgxsConfig {\n    constructor() {\n        /**\n         * Defining the default state before module initialization\n         * This is convenient if we need to create a define our own set of states.\n         * @deprecated will be removed after v4\n         * (default: {})\n         */\n        this.defaultsState = {};\n        /**\n         * Defining shared selector options\n         */\n        this.selectorOptions = {\n            injectContainerState: true,\n            suppressErrors: true // TODO: default is true in v3, will change in v4\n        };\n        this.compatibility = {\n            strictContentSecurityPolicy: false\n        };\n        this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n    }\n}\n/** @nocollapse */ NgxsConfig.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsConfig.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsConfig, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nclass NgxsSimpleChange {\n    constructor(previousValue, currentValue, firstChange) {\n        this.previousValue = previousValue;\n        this.currentValue = currentValue;\n        this.firstChange = firstChange;\n    }\n}\n\nclass NoopNgxsExecutionStrategy {\n    enter(func) {\n        return func();\n    }\n    leave(func) {\n        return func();\n    }\n}\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NoopNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NoopNgxsExecutionStrategy, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }] });\n\n/**\n * The strategy that might be provided by users through `options.executionStrategy`.\n */\nconst USER_PROVIDED_NGXS_EXECUTION_STRATEGY = new InjectionToken('USER_PROVIDED_NGXS_EXECUTION_STRATEGY');\n/*\n * Internal execution strategy injection token\n */\nconst NGXS_EXECUTION_STRATEGY = new InjectionToken('NGXS_EXECUTION_STRATEGY', {\n    providedIn: 'root',\n    factory: () => {\n        const injector = inject(INJECTOR);\n        const executionStrategy = injector.get(USER_PROVIDED_NGXS_EXECUTION_STRATEGY);\n        return executionStrategy\n            ? injector.get(executionStrategy)\n            : injector.get(typeof ɵglobal.Zone !== 'undefined'\n                ? DispatchOutsideZoneNgxsExecutionStrategy\n                : NoopNgxsExecutionStrategy);\n    }\n});\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nfunction ensureStoreMetadata$1(target) {\n    if (!target.hasOwnProperty(META_KEY)) {\n        const defaultMetadata = {\n            name: null,\n            actions: {},\n            defaults: {},\n            path: null,\n            makeRootSelector(context) {\n                return context.getStateGetter(defaultMetadata.name);\n            },\n            children: []\n        };\n        Object.defineProperty(target, META_KEY, { value: defaultMetadata });\n    }\n    return getStoreMetadata$1(target);\n}\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nfunction getStoreMetadata$1(target) {\n    return target[META_KEY];\n}\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nfunction ensureSelectorMetadata$1(target) {\n    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n        const defaultMetadata = {\n            makeRootSelector: null,\n            originalFn: null,\n            containerClass: null,\n            selectorName: null,\n            getSelectorOptions: () => ({})\n        };\n        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\n    }\n    return getSelectorMetadata$1(target);\n}\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nfunction getSelectorMetadata$1(target) {\n    return target[SELECTOR_META_KEY];\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths) {\n    const copyOfPaths = paths.slice();\n    return obj => copyOfPaths.reduce((acc, part) => acc && acc[part], obj);\n}\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths) {\n    const segments = paths;\n    let seg = 'store.' + segments[0];\n    let i = 0;\n    const l = segments.length;\n    let expr = seg;\n    while (++i < l) {\n        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n    }\n    const fn = new Function('store', 'return ' + expr + ';');\n    return fn;\n}\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nfunction propGetter(paths, config) {\n    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n        return compliantPropGetter(paths);\n    }\n    else {\n        return fastPropGetter(paths);\n    }\n}\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nfunction buildGraph(stateClasses) {\n    const findName = (stateClass) => {\n        const meta = stateClasses.find(g => g === stateClass);\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !meta) {\n            throw new Error(`Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`);\n        }\n        return meta[META_KEY].name;\n    };\n    return stateClasses.reduce((result, stateClass) => {\n        const { name, children } = stateClass[META_KEY];\n        result[name] = (children || []).map(findName);\n        return result;\n    }, {});\n}\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nfunction nameToState(states) {\n    return states.reduce((result, stateClass) => {\n        const meta = stateClass[META_KEY];\n        result[meta.name] = stateClass;\n        return result;\n    }, {});\n}\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nfunction findFullParentPath(obj, newObj = {}) {\n    const visit = (child, keyToFind) => {\n        for (const key in child) {\n            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n                const parent = visit(child, key);\n                return parent !== null ? `${parent}.${key}` : key;\n            }\n        }\n        return null;\n    };\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            const parent = visit(obj, key);\n            newObj[key] = parent ? `${parent}.${key}` : key;\n        }\n    }\n    return newObj;\n}\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nfunction topologicalSort(graph) {\n    const sorted = [];\n    const visited = {};\n    const visit = (name, ancestors = []) => {\n        if (!Array.isArray(ancestors)) {\n            ancestors = [];\n        }\n        ancestors.push(name);\n        visited[name] = true;\n        graph[name].forEach((dep) => {\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) && ancestors.indexOf(dep) >= 0) {\n                throw new Error(`Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`);\n            }\n            if (visited[dep]) {\n                return;\n            }\n            visit(dep, ancestors.slice(0));\n        });\n        if (sorted.indexOf(name) < 0) {\n            sorted.push(name);\n        }\n    };\n    Object.keys(graph).forEach(k => visit(k));\n    return sorted.reverse();\n}\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nfunction isObject$1(obj) {\n    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\n}\n\n/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nfunction getActionTypeFromInstance(action) {\n    if (action.constructor && action.constructor.type) {\n        return action.constructor.type;\n    }\n    else {\n        return action.type;\n    }\n}\n/**\n * Matches a action\n * @ignore\n */\nfunction actionMatcher(action1) {\n    const type1 = getActionTypeFromInstance(action1);\n    return function (action2) {\n        return type1 === getActionTypeFromInstance(action2);\n    };\n}\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nconst setValue = (obj, prop, val) => {\n    obj = Object.assign({}, obj);\n    const split = prop.split('.');\n    const lastIndex = split.length - 1;\n    split.reduce((acc, part, index) => {\n        if (index === lastIndex) {\n            acc[part] = val;\n        }\n        else {\n            acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : Object.assign({}, acc[part]);\n        }\n        return acc && acc[part];\n    }, obj);\n    return obj;\n};\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nconst getValue = (obj, prop) => prop.split('.').reduce((acc, part) => acc && acc[part], obj);\n/**\n * Simple object check.\n *\n *    isObject({a:1}) //=> true\n *    isObject(1) //=> false\n *\n * @ignore\n */\nconst isObject = (item) => {\n    return item && typeof item === 'object' && !Array.isArray(item);\n};\n/**\n * Deep merge two objects.\n *\n *    mergeDeep({a:1, b:{x: 1, y:2}}, {b:{x: 3}, c:4}) //=> {a:1, b:{x:3, y:2}, c:4}\n *\n * @param base base object onto which `sources` will be applied\n */\nconst mergeDeep = (base, ...sources) => {\n    if (!sources.length)\n        return base;\n    const source = sources.shift();\n    if (isObject(base) && isObject(source)) {\n        for (const key in source) {\n            if (isObject(source[key])) {\n                if (!base[key])\n                    Object.assign(base, { [key]: {} });\n                mergeDeep(base[key], source[key]);\n            }\n            else {\n                Object.assign(base, { [key]: source[key] });\n            }\n        }\n    }\n    return mergeDeep(base, ...sources);\n};\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nfunction ofAction(...allowedTypes) {\n    return ofActionOperator(allowedTypes);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nfunction ofActionDispatched(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"DISPATCHED\" /* Dispatched */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nfunction ofActionSuccessful(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"SUCCESSFUL\" /* Successful */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nfunction ofActionCanceled(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"CANCELED\" /* Canceled */]);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nfunction ofActionCompleted(...allowedTypes) {\n    const allowedStatuses = [\n        \"SUCCESSFUL\" /* Successful */,\n        \"CANCELED\" /* Canceled */,\n        \"ERRORED\" /* Errored */\n    ];\n    return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nfunction ofActionErrored(...allowedTypes) {\n    return ofActionOperator(allowedTypes, [\"ERRORED\" /* Errored */]);\n}\nfunction ofActionOperator(allowedTypes, statuses, \n// This actually could've been `OperatorFunction<ActionContext, ActionCompletion | any>`,\n// since it maps either to `ctx.action` OR to `ActionCompletion`. But `ActionCompleteion | any`\n// defaults to `any`, thus there is no sense from union type.\nmapOperator = mapAction) {\n    const allowedMap = createAllowedActionTypesMap(allowedTypes);\n    const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n    return function (o) {\n        return o.pipe(filterStatus(allowedMap, allowedStatusMap), mapOperator());\n    };\n}\nfunction filterStatus(allowedTypes, allowedStatuses) {\n    return filter((ctx) => {\n        const actionType = getActionTypeFromInstance(ctx.action);\n        const typeMatch = allowedTypes[actionType];\n        const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n        return typeMatch && statusMatch;\n    });\n}\nfunction mapActionResult() {\n    return map(({ action, status, error }) => {\n        return {\n            action,\n            result: {\n                successful: \"SUCCESSFUL\" /* Successful */ === status,\n                canceled: \"CANCELED\" /* Canceled */ === status,\n                error\n            }\n        };\n    });\n}\nfunction mapAction() {\n    return map((ctx) => ctx.action);\n}\nfunction createAllowedActionTypesMap(types) {\n    return types.reduce((filterMap, klass) => {\n        filterMap[getActionTypeFromInstance(klass)] = true;\n        return filterMap;\n    }, {});\n}\nfunction createAllowedStatusesMap(statuses) {\n    return statuses.reduce((filterMap, status) => {\n        filterMap[status] = true;\n        return filterMap;\n    }, {});\n}\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nfunction leaveNgxs(ngxsExecutionStrategy) {\n    return (source) => {\n        return new Observable((sink) => {\n            return source.subscribe({\n                next(value) {\n                    ngxsExecutionStrategy.leave(() => sink.next(value));\n                },\n                error(error) {\n                    ngxsExecutionStrategy.leave(() => sink.error(error));\n                },\n                complete() {\n                    ngxsExecutionStrategy.leave(() => sink.complete());\n                }\n            });\n        });\n    };\n}\n\nclass InternalNgxsExecutionStrategy {\n    constructor(_executionStrategy) {\n        this._executionStrategy = _executionStrategy;\n    }\n    enter(func) {\n        return this._executionStrategy.enter(func);\n    }\n    leave(func) {\n        return this._executionStrategy.leave(func);\n    }\n}\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, deps: [{ token: NGXS_EXECUTION_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalNgxsExecutionStrategy.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalNgxsExecutionStrategy, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_EXECUTION_STRATEGY]\n                }] }]; } });\n\n/**\n * This wraps the provided function, and will enforce the following:\n * - The calls will execute in the order that they are made\n * - A call will only be initiated when the previous call has completed\n * - If there is a call currently executing then the new call will be added\n *   to the queue and the function will return immediately\n *\n * NOTE: The following assumptions about the operation must hold true:\n * - The operation is synchronous in nature\n * - If any asynchronous side effects of the call exist, it should not\n *   have any bearing on the correctness of the next call in the queue\n * - The operation has a void return\n * - The caller should not assume that the call has completed upon\n *   return of the function\n * - The caller can assume that all the queued calls will complete\n *   within the current microtask\n * - The only way that a call will encounter another call in the queue\n *   would be if the call at the front of the queue initiated this call\n *   as part of its synchronous execution\n */\nfunction orderedQueueOperation(operation) {\n    const callsQueue = [];\n    let busyPushingNext = false;\n    return function callOperation(...args) {\n        if (busyPushingNext) {\n            callsQueue.unshift(args);\n            return;\n        }\n        busyPushingNext = true;\n        operation(...args);\n        while (callsQueue.length > 0) {\n            const nextCallArgs = callsQueue.pop();\n            nextCallArgs && operation(...nextCallArgs);\n        }\n        busyPushingNext = false;\n    };\n}\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedSubject extends Subject {\n    constructor() {\n        super(...arguments);\n        this.next = orderedQueueOperation((value) => super.next(value));\n    }\n}\n/**\n * Custom BehaviorSubject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard BehaviorSubject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new BehaviorSubject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `BehaviorSubject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedBehaviorSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nclass OrderedBehaviorSubject extends BehaviorSubject {\n    constructor() {\n        super(...arguments);\n        this.next = orderedQueueOperation((value) => super.next(value));\n    }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\nclass InternalActions extends OrderedSubject {\n    ngOnDestroy() {\n        this.complete();\n    }\n}\n/** @nocollapse */ InternalActions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalActions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalActions, decorators: [{\n            type: Injectable\n        }] });\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\nclass Actions extends Observable {\n    constructor(internalActions$, internalExecutionStrategy) {\n        const sharedInternalActions$ = internalActions$.pipe(leaveNgxs(internalExecutionStrategy), \n        // The `InternalActions` subject emits outside of the Angular zone.\n        // We have to re-enter the Angular zone for any incoming consumer.\n        // The `share()` operator reduces the number of change detections.\n        // This would call leave only once for any stream emission across all active subscribers.\n        share());\n        super(observer => {\n            const childSubscription = sharedInternalActions$.subscribe({\n                next: ctx => observer.next(ctx),\n                error: error => observer.error(error),\n                complete: () => observer.complete()\n            });\n            observer.add(childSubscription);\n        });\n    }\n}\n/** @nocollapse */ Actions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, deps: [{ token: InternalActions }, { token: InternalNgxsExecutionStrategy }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Actions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Actions, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalNgxsExecutionStrategy }]; } });\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nconst compose = (funcs) => (...args) => {\n    const curr = funcs.shift();\n    return curr(...args, (...nextArgs) => compose(funcs)(...nextArgs));\n};\n\n/**\n * This operator is used for piping the observable result\n * from the `dispatch()`. It has a \"smart\" error handling\n * strategy that allows us to decide whether we propagate\n * errors to Angular's `ErrorHandler` or enable users to\n * handle them manually. We consider following cases:\n * 1) `store.dispatch()` (no subscribe) -> call `handleError()`\n * 2) `store.dispatch().subscribe()` (no error callback) -> call `handleError()`\n * 3) `store.dispatch().subscribe({ error: ... })` -> don't call `handleError()`\n * 4) `toPromise()` without `catch` -> do `handleError()`\n * 5) `toPromise()` with `catch` -> don't `handleError()`\n */\nfunction ngxsErrorHandler(internalErrorReporter, ngxsExecutionStrategy) {\n    return (source) => {\n        let subscribed = false;\n        source.subscribe({\n            error: error => {\n                // Do not trigger change detection for a microtask. This depends on the execution\n                // strategy being used, but the default `DispatchOutsideZoneNgxsExecutionStrategy`\n                // leaves the Angular zone.\n                ngxsExecutionStrategy.enter(() => Promise.resolve().then(() => {\n                    if (!subscribed) {\n                        ngxsExecutionStrategy.leave(() => internalErrorReporter.reportErrorSafely(error));\n                    }\n                }));\n            }\n        });\n        return new Observable(subscriber => {\n            subscribed = true;\n            return source.pipe(leaveNgxs(ngxsExecutionStrategy)).subscribe(subscriber);\n        });\n    };\n}\nclass InternalErrorReporter {\n    constructor(_injector) {\n        this._injector = _injector;\n        /** Will be set lazily to be backward compatible. */\n        this._errorHandler = null;\n    }\n    reportErrorSafely(error) {\n        if (this._errorHandler === null) {\n            this._errorHandler = this._injector.get(ErrorHandler);\n        }\n        // The `try-catch` is used to avoid handling the error twice. Suppose we call\n        // `handleError` which re-throws the error internally. The re-thrown error will\n        // be caught by zone.js which will then get to the `zone.onError.emit()` and the\n        // `onError` subscriber will call `handleError` again.\n        try {\n            this._errorHandler.handleError(error);\n        }\n        catch (_a) { }\n    }\n}\n/** @nocollapse */ InternalErrorReporter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalErrorReporter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, providedIn: 'root' });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalErrorReporter, decorators: [{\n            type: Injectable,\n            args: [{ providedIn: 'root' }]\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\nclass StateStream extends OrderedBehaviorSubject {\n    constructor() {\n        super({});\n    }\n    ngOnDestroy() {\n        // The `StateStream` should never emit values once the root view is removed, e.g. when the `NgModuleRef.destroy()` is called.\n        // This will eliminate memory leaks in server-side rendered apps where the `StateStream` is created per each HTTP request, users\n        // might forget to unsubscribe from `store.select` or `store.subscribe`, thus this will lead to huge memory leaks in SSR apps.\n        this.complete();\n    }\n}\n/** @nocollapse */ StateStream.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateStream.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateStream, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\nclass PluginManager {\n    constructor(_parentManager, _pluginHandlers) {\n        this._parentManager = _parentManager;\n        this._pluginHandlers = _pluginHandlers;\n        this.plugins = [];\n        this.registerHandlers();\n    }\n    get rootPlugins() {\n        return (this._parentManager && this._parentManager.plugins) || this.plugins;\n    }\n    registerHandlers() {\n        const pluginHandlers = this.getPluginHandlers();\n        this.rootPlugins.push(...pluginHandlers);\n    }\n    getPluginHandlers() {\n        const handlers = this._pluginHandlers || [];\n        return handlers.map((plugin) => (plugin.handle ? plugin.handle.bind(plugin) : plugin));\n    }\n}\n/** @nocollapse */ PluginManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, deps: [{ token: PluginManager, optional: true, skipSelf: true }, { token: NGXS_PLUGINS, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ PluginManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: PluginManager, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: PluginManager, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_PLUGINS]\n                }, {\n                    type: Optional\n                }] }]; } });\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\nclass InternalDispatchedActionResults extends Subject {\n}\n/** @nocollapse */ InternalDispatchedActionResults.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatchedActionResults.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatchedActionResults, decorators: [{\n            type: Injectable\n        }] });\nclass InternalDispatcher {\n    constructor(_actions, _actionResults, _pluginManager, _stateStream, _ngxsExecutionStrategy, _internalErrorReporter) {\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._pluginManager = _pluginManager;\n        this._stateStream = _stateStream;\n        this._ngxsExecutionStrategy = _ngxsExecutionStrategy;\n        this._internalErrorReporter = _internalErrorReporter;\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        const result = this._ngxsExecutionStrategy.enter(() => this.dispatchByEvents(actionOrActions));\n        return result.pipe(ngxsErrorHandler(this._internalErrorReporter, this._ngxsExecutionStrategy));\n    }\n    dispatchByEvents(actionOrActions) {\n        if (Array.isArray(actionOrActions)) {\n            if (actionOrActions.length === 0)\n                return of(this._stateStream.getValue());\n            return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n        }\n        else {\n            return this.dispatchSingle(actionOrActions);\n        }\n    }\n    dispatchSingle(action) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const type = getActionTypeFromInstance(action);\n            if (!type) {\n                const error = new Error(`This action doesn't have a type property: ${action.constructor.name}`);\n                return throwError(error);\n            }\n        }\n        const prevState = this._stateStream.getValue();\n        const plugins = this._pluginManager.plugins;\n        return compose([\n            ...plugins,\n            (nextState, nextAction) => {\n                if (nextState !== prevState) {\n                    this._stateStream.next(nextState);\n                }\n                const actionResult$ = this.getActionResultStream(nextAction);\n                actionResult$.subscribe(ctx => this._actions.next(ctx));\n                this._actions.next({ action: nextAction, status: \"DISPATCHED\" /* Dispatched */ });\n                return this.createDispatchObservable(actionResult$);\n            }\n        ])(prevState, action).pipe(shareReplay());\n    }\n    getActionResultStream(action) {\n        return this._actionResults.pipe(filter((ctx) => ctx.action === action && ctx.status !== \"DISPATCHED\" /* Dispatched */), take(1), shareReplay());\n    }\n    createDispatchObservable(actionResult$) {\n        return actionResult$\n            .pipe(exhaustMap((ctx) => {\n            switch (ctx.status) {\n                case \"SUCCESSFUL\" /* Successful */:\n                    return of(this._stateStream.getValue());\n                case \"ERRORED\" /* Errored */:\n                    return throwError(ctx.error);\n                default:\n                    return EMPTY;\n            }\n        }))\n            .pipe(shareReplay());\n    }\n}\n/** @nocollapse */ InternalDispatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, deps: [{ token: InternalActions }, { token: InternalDispatchedActionResults }, { token: PluginManager }, { token: StateStream }, { token: InternalNgxsExecutionStrategy }, { token: InternalErrorReporter }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalDispatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalDispatcher, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalActions }, { type: InternalDispatchedActionResults }, { type: PluginManager }, { type: StateStream }, { type: InternalNgxsExecutionStrategy }, { type: InternalErrorReporter }]; } });\n\n/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nconst deepFreeze = (o) => {\n    Object.freeze(o);\n    const oIsFunction = typeof o === 'function';\n    const hasOwnProp = Object.prototype.hasOwnProperty;\n    Object.getOwnPropertyNames(o).forEach(function (prop) {\n        if (hasOwnProp.call(o, prop) &&\n            (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n            o[prop] !== null &&\n            (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n            !Object.isFrozen(o[prop])) {\n            deepFreeze(o[prop]);\n        }\n    });\n    return o;\n};\n\n/**\n * State Context factory class\n * @ignore\n */\nclass InternalStateOperations {\n    constructor(_stateStream, _dispatcher, _config) {\n        this._stateStream = _stateStream;\n        this._dispatcher = _dispatcher;\n        this._config = _config;\n    }\n    /**\n     * Returns the root state operators.\n     */\n    getRootStateOperations() {\n        const rootStateOperations = {\n            getState: () => this._stateStream.getValue(),\n            setState: (newState) => this._stateStream.next(newState),\n            dispatch: (actionOrActions) => this._dispatcher.dispatch(actionOrActions)\n        };\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            return this._config.developmentMode\n                ? ensureStateAndActionsAreImmutable(rootStateOperations)\n                : rootStateOperations;\n        }\n        else {\n            return rootStateOperations;\n        }\n    }\n    setStateToTheCurrentWithNew(results) {\n        const stateOperations = this.getRootStateOperations();\n        // Get our current stream\n        const currentState = stateOperations.getState();\n        // Set the state to the current + new\n        stateOperations.setState(Object.assign(Object.assign({}, currentState), results.defaults));\n    }\n}\n/** @nocollapse */ InternalStateOperations.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, deps: [{ token: StateStream }, { token: InternalDispatcher }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ InternalStateOperations.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: InternalStateOperations, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalDispatcher }, { type: NgxsConfig }]; } });\nfunction ensureStateAndActionsAreImmutable(root) {\n    return {\n        getState: () => root.getState(),\n        setState: value => {\n            const frozenValue = deepFreeze(value);\n            return root.setState(frozenValue);\n        },\n        dispatch: actions => {\n            return root.dispatch(actions);\n        }\n    };\n}\n\nfunction simplePatch(value) {\n    return (existingState) => {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (Array.isArray(value)) {\n                throwPatchingArrayError();\n            }\n            else if (typeof value !== 'object') {\n                throwPatchingPrimitiveError();\n            }\n        }\n        const newState = Object.assign({}, existingState);\n        for (const key in value) {\n            // deep clone for patch compatibility\n            newState[key] = value[key];\n        }\n        return newState;\n    };\n}\n\n/**\n * State Context factory class\n * @ignore\n */\nclass StateContextFactory {\n    constructor(_internalStateOperations) {\n        this._internalStateOperations = _internalStateOperations;\n    }\n    /**\n     * Create the state context\n     */\n    createStateContext(mappedStore) {\n        const root = this._internalStateOperations.getRootStateOperations();\n        function getState(currentAppState) {\n            return getValue(currentAppState, mappedStore.path);\n        }\n        function setStateValue(currentAppState, newValue) {\n            const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n            root.setState(newAppState);\n            return newAppState;\n            // In doing this refactoring I noticed that there is a 'bug' where the\n            // application state is returned instead of this state slice.\n            // This has worked this way since the beginning see:\n            // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n            // This needs to be fixed, but is a 'breaking' change.\n            // I will do this fix in a subsequent PR and we can decide how to handle it.\n        }\n        function setStateFromOperator(currentAppState, stateOperator) {\n            const local = getState(currentAppState);\n            const newValue = stateOperator(local);\n            return setStateValue(currentAppState, newValue);\n        }\n        function isStateOperator(value) {\n            return typeof value === 'function';\n        }\n        return {\n            getState() {\n                const currentAppState = root.getState();\n                return getState(currentAppState);\n            },\n            patchState(val) {\n                const currentAppState = root.getState();\n                const patchOperator = simplePatch(val);\n                return setStateFromOperator(currentAppState, patchOperator);\n            },\n            setState(val) {\n                const currentAppState = root.getState();\n                return isStateOperator(val)\n                    ? setStateFromOperator(currentAppState, val)\n                    : setStateValue(currentAppState, val);\n            },\n            dispatch(actions) {\n                return root.dispatch(actions);\n            }\n        };\n    }\n}\n/** @nocollapse */ StateContextFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, deps: [{ token: InternalStateOperations }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateContextFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateContextFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: InternalStateOperations }]; } });\n\nclass StoreValidators {\n    static checkThatStateIsNamedCorrectly(name) {\n        if (!name) {\n            throwStateNamePropertyError();\n        }\n        else if (!this.stateNameRegex.test(name)) {\n            throwStateNameError(name);\n        }\n    }\n    static checkThatStateNameIsUnique(stateName, state, statesByName) {\n        const existingState = statesByName[stateName];\n        if (existingState && existingState !== state) {\n            throwStateUniqueError(stateName, state.name, existingState.name);\n        }\n    }\n    static checkThatStateClassesHaveBeenDecorated(stateClasses) {\n        stateClasses.forEach((stateClass) => {\n            if (!getStoreMetadata$1(stateClass)) {\n                throwStateDecoratorError(stateClass.name);\n            }\n        });\n    }\n}\nStoreValidators.stateNameRegex = new RegExp('^[a-zA-Z0-9_]+$');\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nfunction ensureStateClassIsInjectable(stateClass) {\n    // `ɵprov` is a static property added by the NGCC compiler. It always exists in\n    // AOT mode because this property is added before runtime. If an application is running in\n    // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n    // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n    const ngInjectableDef = stateClass.ɵprov;\n    if (!ngInjectableDef) {\n        // Don't warn if Ivy is disabled or `ɵprov` exists on the class\n        console.warn(getUndecoratedStateInIvyWarningMessage(stateClass.name));\n    }\n}\n\n/**\n * Init action\n */\nclass InitState {\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@INIT';\n    }\n}\n/**\n * Update action\n */\nclass UpdateState {\n    constructor(addedStates) {\n        this.addedStates = addedStates;\n    }\n    static get type() {\n        // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n        return '@@UPDATE_STATE';\n    }\n}\n\nconst NGXS_DEVELOPMENT_OPTIONS = new InjectionToken('NGXS_DEVELOPMENT_OPTIONS', {\n    providedIn: 'root',\n    factory: () => ({ warnOnUnhandledActions: true })\n});\n\nclass NgxsUnhandledActionsLogger {\n    constructor(options) {\n        /**\n         * These actions should be ignored by default; the user can increase this\n         * list in the future via the `ignoreActions` method.\n         */\n        this._ignoredActions = new Set([InitState.type, UpdateState.type]);\n        if (typeof options.warnOnUnhandledActions === 'object') {\n            this.ignoreActions(...options.warnOnUnhandledActions.ignore);\n        }\n    }\n    /**\n     * Adds actions to the internal list of actions that should be ignored.\n     */\n    ignoreActions(...actions) {\n        for (const action of actions) {\n            this._ignoredActions.add(action.type);\n        }\n    }\n    /** @internal */\n    warn(action) {\n        const actionShouldBeIgnored = Array.from(this._ignoredActions).some(type => type === getActionTypeFromInstance(action));\n        if (actionShouldBeIgnored) {\n            return;\n        }\n        action =\n            action.constructor && action.constructor.name !== 'Object'\n                ? action.constructor.name\n                : action.type;\n        console.warn(`The ${action} action has been dispatched but hasn't been handled. This may happen if the state with an action handler for this action is not registered.`);\n    }\n}\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, deps: [{ token: NGXS_DEVELOPMENT_OPTIONS }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ NgxsUnhandledActionsLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsUnhandledActionsLogger, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: undefined, decorators: [{\n                    type: Inject,\n                    args: [NGXS_DEVELOPMENT_OPTIONS]\n                }] }]; } });\n\n/**\n * State factory class\n * @ignore\n */\nclass StateFactory {\n    constructor(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {\n        this._injector = _injector;\n        this._config = _config;\n        this._parentFactory = _parentFactory;\n        this._actions = _actions;\n        this._actionResults = _actionResults;\n        this._stateContextFactory = _stateContextFactory;\n        this._initialState = _initialState;\n        this._actionsSubscription = null;\n        this._states = [];\n        this._statesByName = {};\n        this._statePaths = {};\n        this.getRuntimeSelectorContext = memoize(() => {\n            // eslint-disable-next-line @typescript-eslint/no-this-alias\n            const stateFactory = this;\n            function resolveGetter(key) {\n                const path = stateFactory.statePaths[key];\n                return path ? propGetter(path.split('.'), stateFactory._config) : null;\n            }\n            const context = this._parentFactory\n                ? this._parentFactory.getRuntimeSelectorContext()\n                : {\n                    getStateGetter(key) {\n                        let getter = resolveGetter(key);\n                        if (getter) {\n                            return getter;\n                        }\n                        return (...args) => {\n                            // Late loaded getter\n                            if (!getter) {\n                                getter = resolveGetter(key);\n                            }\n                            return getter ? getter(...args) : undefined;\n                        };\n                    },\n                    getSelectorOptions(localOptions) {\n                        const globalSelectorOptions = stateFactory._config.selectorOptions;\n                        return Object.assign(Object.assign({}, globalSelectorOptions), (localOptions || {}));\n                    }\n                };\n            return context;\n        });\n    }\n    get states() {\n        return this._parentFactory ? this._parentFactory.states : this._states;\n    }\n    get statesByName() {\n        return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n    }\n    get statePaths() {\n        return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n    }\n    static cloneDefaults(defaults) {\n        let value = {};\n        if (Array.isArray(defaults)) {\n            value = defaults.slice();\n        }\n        else if (isObject$1(defaults)) {\n            value = Object.assign({}, defaults);\n        }\n        else if (defaults === undefined) {\n            value = {};\n        }\n        else {\n            value = defaults;\n        }\n        return value;\n    }\n    ngOnDestroy() {\n        // This is being non-null asserted since `_actionsSubscrition` is\n        // initialized within the constructor.\n        this._actionsSubscription.unsubscribe();\n    }\n    /**\n     * Add a new state to the global defs.\n     */\n    add(stateClasses) {\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            StoreValidators.checkThatStateClassesHaveBeenDecorated(stateClasses);\n        }\n        const { newStates } = this.addToStatesMap(stateClasses);\n        if (!newStates.length)\n            return [];\n        const stateGraph = buildGraph(newStates);\n        const sortedStates = topologicalSort(stateGraph);\n        const paths = findFullParentPath(stateGraph);\n        const nameGraph = nameToState(newStates);\n        const bootstrappedStores = [];\n        for (const name of sortedStates) {\n            const stateClass = nameGraph[name];\n            const path = paths[name];\n            const meta = stateClass[META_KEY];\n            this.addRuntimeInfoToMeta(meta, path);\n            // Note: previously we called `ensureStateClassIsInjectable` within the\n            // `State` decorator. This check is moved here because the `ɵprov` property\n            // will not exist on the class in JIT mode (because it's set asynchronously\n            // during JIT compilation through `Object.defineProperty`).\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                ensureStateClassIsInjectable(stateClass);\n            }\n            const stateMap = {\n                name,\n                path,\n                isInitialised: false,\n                actions: meta.actions,\n                instance: this._injector.get(stateClass),\n                defaults: StateFactory.cloneDefaults(meta.defaults)\n            };\n            // ensure our store hasn't already been added\n            // but don't throw since it could be lazy\n            // loaded from different paths\n            if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n                bootstrappedStores.push(stateMap);\n            }\n            this.states.push(stateMap);\n        }\n        return bootstrappedStores;\n    }\n    /**\n     * Add a set of states to the store and return the defaults\n     */\n    addAndReturnDefaults(stateClasses) {\n        const classes = stateClasses || [];\n        const mappedStores = this.add(classes);\n        const defaults = mappedStores.reduce((result, mappedStore) => setValue(result, mappedStore.path, mappedStore.defaults), {});\n        return { defaults, states: mappedStores };\n    }\n    /**\n     * Bind the actions to the handlers\n     */\n    connectActionHandlers() {\n        if (this._actionsSubscription !== null)\n            return;\n        const dispatched$ = new Subject();\n        this._actionsSubscription = this._actions\n            .pipe(filter((ctx) => ctx.status === \"DISPATCHED\" /* Dispatched */), mergeMap(ctx => {\n            dispatched$.next(ctx);\n            const action = ctx.action;\n            return this.invokeActions(dispatched$, action).pipe(map(() => ({ action, status: \"SUCCESSFUL\" /* Successful */ })), defaultIfEmpty({ action, status: \"CANCELED\" /* Canceled */ }), catchError(error => of({ action, status: \"ERRORED\" /* Errored */, error })));\n        }))\n            .subscribe(ctx => this._actionResults.next(ctx));\n    }\n    /**\n     * Invoke actions on the states.\n     */\n    invokeActions(dispatched$, action) {\n        const type = getActionTypeFromInstance(action);\n        const results = [];\n        // Determines whether the dispatched action has been handled, this is assigned\n        // to `true` within the below `for` loop if any `actionMetas` has been found.\n        let actionHasBeenHandled = false;\n        for (const metadata of this.states) {\n            const actionMetas = metadata.actions[type];\n            if (actionMetas) {\n                for (const actionMeta of actionMetas) {\n                    const stateContext = this._stateContextFactory.createStateContext(metadata);\n                    try {\n                        let result = metadata.instance[actionMeta.fn](stateContext, action);\n                        if (result instanceof Promise) {\n                            result = from(result);\n                        }\n                        if (isObservable(result)) {\n                            // If this observable has been completed w/o emitting\n                            // any value then we wouldn't want to complete the whole chain\n                            // of actions. Since if any observable completes then\n                            // action will be canceled.\n                            // For instance if any action handler would've had such statement:\n                            // `handler(ctx) { return EMPTY; }`\n                            // then the action will be canceled.\n                            // See https://github.com/ngxs/store/issues/1568\n                            result = result.pipe(mergeMap((value) => {\n                                if (value instanceof Promise) {\n                                    return from(value);\n                                }\n                                if (isObservable(value)) {\n                                    return value;\n                                }\n                                return of(value);\n                            }), defaultIfEmpty({}));\n                            if (actionMeta.options.cancelUncompleted) {\n                                // todo: ofActionDispatched should be used with action class\n                                result = result.pipe(takeUntil(dispatched$.pipe(ofActionDispatched(action))));\n                            }\n                        }\n                        else {\n                            result = of({}).pipe(shareReplay());\n                        }\n                        results.push(result);\n                    }\n                    catch (e) {\n                        results.push(throwError(e));\n                    }\n                    actionHasBeenHandled = true;\n                }\n            }\n        }\n        // The `NgxsUnhandledActionsLogger` is a tree-shakable class which functions\n        // only during development.\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && !actionHasBeenHandled) {\n            const unhandledActionsLogger = this._injector.get(NgxsUnhandledActionsLogger, null);\n            // The `NgxsUnhandledActionsLogger` will not be resolved by the injector if the\n            // `NgxsDevelopmentModule` is not provided. It's enough to check whether the `injector.get`\n            // didn't return `null` so we may ensure the module has been imported.\n            if (unhandledActionsLogger) {\n                unhandledActionsLogger.warn(action);\n            }\n        }\n        if (!results.length) {\n            results.push(of({}));\n        }\n        return forkJoin(results);\n    }\n    addToStatesMap(stateClasses) {\n        const newStates = [];\n        const statesMap = this.statesByName;\n        for (const stateClass of stateClasses) {\n            const stateName = getStoreMetadata$1(stateClass).name;\n            // Caretaker note: we have still left the `typeof` condition in order to avoid\n            // creating a breaking change for projects that still use the View Engine.\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                StoreValidators.checkThatStateNameIsUnique(stateName, stateClass, statesMap);\n            }\n            const unmountedState = !statesMap[stateName];\n            if (unmountedState) {\n                newStates.push(stateClass);\n                statesMap[stateName] = stateClass;\n            }\n        }\n        return { newStates };\n    }\n    addRuntimeInfoToMeta(meta, path) {\n        this.statePaths[meta.name] = path;\n        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n        // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n        // We will need to come up with an alternative in v4 because this is used by many plugins\n        meta.path = path;\n    }\n    /**\n     * @description\n     * the method checks if the state has already been added to the tree\n     * and completed the life cycle\n     * @param name\n     * @param path\n     */\n    hasBeenMountedAndBootstrapped(name, path) {\n        const valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;\n        return this.statesByName[name] && valueIsBootstrappedInInitialState;\n    }\n}\n/** @nocollapse */ StateFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, deps: [{ token: i0.Injector }, { token: NgxsConfig }, { token: StateFactory, optional: true, skipSelf: true }, { token: InternalActions }, { token: InternalDispatchedActionResults }, { token: StateContextFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ StateFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: StateFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }, { type: NgxsConfig }, { type: StateFactory, decorators: [{\n                    type: Optional\n                }, {\n                    type: SkipSelf\n                }] }, { type: InternalActions }, { type: InternalDispatchedActionResults }, { type: StateContextFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\nfunction createRootSelectorFactory(selectorMetaData, selectors, memoizedSelectorFn) {\n    return (context) => {\n        const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(context, selectorMetaData, selectors);\n        return function selectFromRoot(rootState) {\n            // Determine arguments from the app state using the selectors\n            const results = argumentSelectorFunctions.map((argFn) => argFn(rootState));\n            // if the lambda tries to access a something on the\n            // state that doesn't exist, it will throw a TypeError.\n            // since this is quite usual behaviour, we simply return undefined if so.\n            try {\n                return memoizedSelectorFn(...results);\n            }\n            catch (ex) {\n                if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n                    return undefined;\n                }\n                throw ex;\n            }\n        };\n    };\n}\nfunction createMemoizedSelectorFn(originalFn, creationMetadata) {\n    const containerClass = creationMetadata && creationMetadata.containerClass;\n    const wrappedFn = function wrappedSelectorFn(...args) {\n        const returnValue = originalFn.apply(containerClass, args);\n        if (returnValue instanceof Function) {\n            const innerMemoizedFn = memoize.apply(null, [returnValue]);\n            return innerMemoizedFn;\n        }\n        return returnValue;\n    };\n    const memoizedFn = memoize(wrappedFn);\n    Object.setPrototypeOf(memoizedFn, originalFn);\n    return memoizedFn;\n}\nfunction getRuntimeSelectorInfo(context, selectorMetaData, selectors = []) {\n    const localSelectorOptions = selectorMetaData.getSelectorOptions();\n    const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n    const selectorsToApply = getSelectorsToApply(selectors, selectorOptions, selectorMetaData.containerClass);\n    const argumentSelectorFunctions = selectorsToApply.map((selector) => {\n        const factory = getRootSelectorFactory(selector);\n        return factory(context);\n    });\n    return {\n        selectorOptions,\n        argumentSelectorFunctions,\n    };\n}\nfunction getSelectorsToApply(selectors = [], selectorOptions, containerClass) {\n    const selectorsToApply = [];\n    const canInjectContainerState = selectors.length === 0 || selectorOptions.injectContainerState;\n    if (containerClass && canInjectContainerState) {\n        // If we are on a state class, add it as the first selector parameter\n        const metadata = getStoreMetadata$1(containerClass);\n        if (metadata) {\n            selectorsToApply.push(containerClass);\n        }\n    }\n    if (selectors) {\n        selectorsToApply.push(...selectors);\n    }\n    return selectorsToApply;\n}\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nfunction getRootSelectorFactory(selector) {\n    const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n    return (metadata && metadata.makeRootSelector) || (() => selector);\n}\n\n// tslint:disable:unified-signatures\nclass Store {\n    constructor(_stateStream, _internalStateOperations, _config, _internalExecutionStrategy, _stateFactory, initialStateValue) {\n        this._stateStream = _stateStream;\n        this._internalStateOperations = _internalStateOperations;\n        this._config = _config;\n        this._internalExecutionStrategy = _internalExecutionStrategy;\n        this._stateFactory = _stateFactory;\n        /**\n         * This is a derived state stream that leaves NGXS execution strategy to emit state changes within the Angular zone,\n         * because state is being changed actually within the `<root>` zone, see `InternalDispatcher#dispatchSingle`.\n         * All selects would use this stream, and it would call leave only once for any state change across all active selectors.\n         */\n        this._selectableStateStream = this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy), shareReplay({ bufferSize: 1, refCount: true }));\n        this.initStateStream(initialStateValue);\n    }\n    /**\n     * Dispatches event(s).\n     */\n    dispatch(actionOrActions) {\n        return this._internalStateOperations.getRootStateOperations().dispatch(actionOrActions);\n    }\n    select(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return this._selectableStateStream.pipe(map(selectorFn), catchError((err) => {\n            // if error is TypeError we swallow it to prevent usual errors with property access\n            const { suppressErrors } = this._config.selectorOptions;\n            if (err instanceof TypeError && suppressErrors) {\n                return of(undefined);\n            }\n            // rethrow other errors\n            return throwError(err);\n        }), distinctUntilChanged(), leaveNgxs(this._internalExecutionStrategy));\n    }\n    selectOnce(selector) {\n        return this.select(selector).pipe(take(1));\n    }\n    selectSnapshot(selector) {\n        const selectorFn = this.getStoreBoundSelectorFn(selector);\n        return selectorFn(this._stateStream.getValue());\n    }\n    /**\n     * Allow the user to subscribe to the root of the state\n     */\n    subscribe(fn) {\n        return this._selectableStateStream\n            .pipe(leaveNgxs(this._internalExecutionStrategy))\n            .subscribe(fn);\n    }\n    /**\n     * Return the raw value of the state.\n     */\n    snapshot() {\n        return this._internalStateOperations.getRootStateOperations().getState();\n    }\n    /**\n     * Reset the state to a specific point in time. This method is useful\n     * for plugin's who need to modify the state directly or unit testing.\n     */\n    reset(state) {\n        return this._internalStateOperations.getRootStateOperations().setState(state);\n    }\n    getStoreBoundSelectorFn(selector) {\n        const makeSelectorFn = getRootSelectorFactory(selector);\n        const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n        return makeSelectorFn(runtimeContext);\n    }\n    initStateStream(initialStateValue) {\n        const value = this._stateStream.value;\n        const storeIsEmpty = !value || Object.keys(value).length === 0;\n        if (storeIsEmpty) {\n            const defaultStateNotEmpty = Object.keys(this._config.defaultsState).length > 0;\n            const storeValues = defaultStateNotEmpty\n                ? Object.assign(Object.assign({}, this._config.defaultsState), initialStateValue) : initialStateValue;\n            this._stateStream.next(storeValues);\n        }\n    }\n}\n/** @nocollapse */ Store.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, deps: [{ token: StateStream }, { token: InternalStateOperations }, { token: NgxsConfig }, { token: InternalNgxsExecutionStrategy }, { token: StateFactory }, { token: INITIAL_STATE_TOKEN, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ Store.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: Store, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: StateStream }, { type: InternalStateOperations }, { type: NgxsConfig }, { type: InternalNgxsExecutionStrategy }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [INITIAL_STATE_TOKEN]\n                }] }]; } });\n\nclass LifecycleStateManager {\n    constructor(_store, _internalErrorReporter, _internalStateOperations, _stateContextFactory, _bootstrapper) {\n        this._store = _store;\n        this._internalErrorReporter = _internalErrorReporter;\n        this._internalStateOperations = _internalStateOperations;\n        this._stateContextFactory = _stateContextFactory;\n        this._bootstrapper = _bootstrapper;\n        this._destroy$ = new Subject();\n    }\n    ngOnDestroy() {\n        this._destroy$.next();\n    }\n    ngxsBootstrap(action, results) {\n        this._internalStateOperations\n            .getRootStateOperations()\n            .dispatch(action)\n            .pipe(filter(() => !!results), tap(() => this._invokeInitOnStates(results.states)), mergeMap(() => this._bootstrapper.appBootstrapped$), filter(appBootstrapped => !!appBootstrapped), catchError(error => {\n            // The `SafeSubscriber` (which is used by most RxJS operators) re-throws\n            // errors asynchronously (`setTimeout(() => { throw error })`). This might\n            // break existing user's code or unit tests. We catch the error manually to\n            // be backward compatible with the old behavior.\n            this._internalErrorReporter.reportErrorSafely(error);\n            return EMPTY;\n        }), takeUntil(this._destroy$))\n            .subscribe(() => this._invokeBootstrapOnStates(results.states));\n    }\n    _invokeInitOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsOnChanges) {\n                this._store\n                    .select(state => getValue(state, mappedStore.path))\n                    .pipe(startWith(undefined), pairwise(), takeUntil(this._destroy$))\n                    .subscribe(([previousValue, currentValue]) => {\n                    const change = new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n                    instance.ngxsOnChanges(change);\n                });\n            }\n            if (instance.ngxsOnInit) {\n                instance.ngxsOnInit(this._getStateContext(mappedStore));\n            }\n            mappedStore.isInitialised = true;\n        }\n    }\n    _invokeBootstrapOnStates(mappedStores) {\n        for (const mappedStore of mappedStores) {\n            const instance = mappedStore.instance;\n            if (instance.ngxsAfterBootstrap) {\n                instance.ngxsAfterBootstrap(this._getStateContext(mappedStore));\n            }\n        }\n    }\n    _getStateContext(mappedStore) {\n        return this._stateContextFactory.createStateContext(mappedStore);\n    }\n}\n/** @nocollapse */ LifecycleStateManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, deps: [{ token: Store }, { token: InternalErrorReporter }, { token: InternalStateOperations }, { token: StateContextFactory }, { token: i5.NgxsBootstrapper }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ LifecycleStateManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: LifecycleStateManager, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalErrorReporter }, { type: InternalStateOperations }, { type: StateContextFactory }, { type: i5.NgxsBootstrapper }]; } });\n\n/**\n * Allows the select decorator to get access to the DI store, this is used internally\n * in `@Select` decorator.\n */\nclass SelectFactory {\n    constructor(store, config) {\n        SelectFactory.store = store;\n        SelectFactory.config = config;\n    }\n    ngOnDestroy() {\n        SelectFactory.store = null;\n        SelectFactory.config = null;\n    }\n}\nSelectFactory.store = null;\nSelectFactory.config = null;\n/** @nocollapse */ SelectFactory.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, deps: [{ token: Store }, { token: NgxsConfig }], target: i0.ɵɵFactoryTarget.Injectable });\n/** @nocollapse */ SelectFactory.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: SelectFactory, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: Store }, { type: NgxsConfig }]; } });\n\n/**\n * Root module\n * @ignore\n */\nclass NgxsRootModule {\n    constructor(factory, internalStateOperations, _store, _select, states = [], lifecycleStateManager) {\n        // Add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(states);\n        internalStateOperations.setStateToTheCurrentWithNew(results);\n        // Connect our actions stream\n        factory.connectActionHandlers();\n        // Dispatch the init action and invoke init and bootstrap functions after\n        lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n    }\n}\n/** @nocollapse */ NgxsRootModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, deps: [{ token: StateFactory }, { token: InternalStateOperations }, { token: Store }, { token: SelectFactory }, { token: ROOT_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsRootModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\n/** @nocollapse */ NgxsRootModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsRootModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: StateFactory }, { type: InternalStateOperations }, { type: Store }, { type: SelectFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [ROOT_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Feature module\n * @ignore\n */\nclass NgxsFeatureModule {\n    constructor(_store, internalStateOperations, factory, states = [], lifecycleStateManager) {\n        // Since FEATURE_STATE_TOKEN is a multi token, we need to\n        // flatten it [[Feature1State, Feature2State], [Feature3State]]\n        const flattenedStates = NgxsFeatureModule.flattenStates(states);\n        // add stores to the state graph and return their defaults\n        const results = factory.addAndReturnDefaults(flattenedStates);\n        if (results.states.length) {\n            internalStateOperations.setStateToTheCurrentWithNew(results);\n            // dispatch the update action and invoke init and bootstrap functions after\n            lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n        }\n    }\n    static flattenStates(states = []) {\n        return states.reduce((total, values) => total.concat(values), []);\n    }\n}\n/** @nocollapse */ NgxsFeatureModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, deps: [{ token: Store }, { token: InternalStateOperations }, { token: StateFactory }, { token: FEATURE_STATE_TOKEN, optional: true }, { token: LifecycleStateManager }], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsFeatureModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\n/** @nocollapse */ NgxsFeatureModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsFeatureModule, decorators: [{\n            type: NgModule\n        }], ctorParameters: function () { return [{ type: Store }, { type: InternalStateOperations }, { type: StateFactory }, { type: undefined, decorators: [{\n                    type: Optional\n                }, {\n                    type: Inject,\n                    args: [FEATURE_STATE_TOKEN]\n                }] }, { type: LifecycleStateManager }]; } });\n\n/**\n * Ngxs Module\n */\nclass NgxsModule {\n    /**\n     * Root module factory\n     */\n    static forRoot(states = [], options = {}) {\n        return {\n            ngModule: NgxsRootModule,\n            providers: [\n                StateFactory,\n                StateContextFactory,\n                Actions,\n                InternalActions,\n                NgxsBootstrapper,\n                LifecycleStateManager,\n                InternalDispatcher,\n                InternalDispatchedActionResults,\n                InternalStateOperations,\n                InternalNgxsExecutionStrategy,\n                Store,\n                StateStream,\n                SelectFactory,\n                PluginManager,\n                ...states,\n                ...NgxsModule.ngxsTokenProviders(states, options)\n            ]\n        };\n    }\n    /**\n     * Feature module factory\n     */\n    static forFeature(states = []) {\n        return {\n            ngModule: NgxsFeatureModule,\n            providers: [\n                StateFactory,\n                PluginManager,\n                ...states,\n                {\n                    provide: FEATURE_STATE_TOKEN,\n                    multi: true,\n                    useValue: states\n                }\n            ]\n        };\n    }\n    static ngxsTokenProviders(states, options) {\n        return [\n            {\n                provide: USER_PROVIDED_NGXS_EXECUTION_STRATEGY,\n                useValue: options.executionStrategy\n            },\n            {\n                provide: ROOT_STATE_TOKEN,\n                useValue: states\n            },\n            {\n                provide: NgxsModule.ROOT_OPTIONS,\n                useValue: options\n            },\n            {\n                provide: NgxsConfig,\n                useFactory: NgxsModule.ngxsConfigFactory,\n                deps: [NgxsModule.ROOT_OPTIONS]\n            },\n            {\n                provide: APP_BOOTSTRAP_LISTENER,\n                useFactory: NgxsModule.appBootstrapListenerFactory,\n                multi: true,\n                deps: [NgxsBootstrapper]\n            },\n            {\n                provide: INITIAL_STATE_TOKEN,\n                useFactory: NgxsModule.getInitialState\n            },\n            {\n                provide: ɵNGXS_STATE_CONTEXT_FACTORY,\n                useExisting: StateContextFactory\n            },\n            {\n                provide: ɵNGXS_STATE_FACTORY,\n                useExisting: StateFactory\n            }\n        ];\n    }\n    static ngxsConfigFactory(options) {\n        return mergeDeep(new NgxsConfig(), options);\n    }\n    static appBootstrapListenerFactory(bootstrapper) {\n        return () => bootstrapper.bootstrap();\n    }\n    static getInitialState() {\n        return InitialState.pop();\n    }\n}\nNgxsModule.ROOT_OPTIONS = new InjectionToken('ROOT_OPTIONS');\n/** @nocollapse */ NgxsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\n/** @nocollapse */ NgxsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsModule, decorators: [{\n            type: NgModule\n        }] });\n\n/**\n * Decorates a method with a action information.\n */\nfunction Action(actions, options) {\n    return (target, name) => {\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            const isStaticMethod = target.hasOwnProperty('prototype');\n            if (isStaticMethod) {\n                throwActionDecoratorError();\n            }\n        }\n        const meta = ensureStoreMetadata$1(target.constructor);\n        if (!Array.isArray(actions)) {\n            actions = [actions];\n        }\n        for (const action of actions) {\n            const type = action.type;\n            if (!meta.actions[type]) {\n                meta.actions[type] = [];\n            }\n            meta.actions[type].push({\n                fn: name,\n                options: options || {},\n                type\n            });\n        }\n    };\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nfunction State(options) {\n    function getStateOptions(inheritedStateClass) {\n        const inheritanceOptions = inheritedStateClass[META_OPTIONS_KEY] || {};\n        return Object.assign(Object.assign({}, inheritanceOptions), options);\n    }\n    function mutateMetaData(params) {\n        const { meta, inheritedStateClass, optionsWithInheritance } = params;\n        const { children, defaults, name } = optionsWithInheritance;\n        const stateName = typeof name === 'string' ? name : (name && name.getName()) || null;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            StoreValidators.checkThatStateIsNamedCorrectly(stateName);\n        }\n        if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n            const inheritedMeta = inheritedStateClass[META_KEY] || {};\n            meta.actions = Object.assign(Object.assign({}, meta.actions), inheritedMeta.actions);\n        }\n        meta.children = children;\n        meta.defaults = defaults;\n        meta.name = stateName;\n    }\n    return (target) => {\n        const stateClass = target;\n        const meta = ensureStoreMetadata$1(stateClass);\n        const inheritedStateClass = Object.getPrototypeOf(stateClass);\n        const optionsWithInheritance = getStateOptions(inheritedStateClass);\n        mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });\n        stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n    };\n}\n\nconst DOLLAR_CHAR_CODE = 36;\nfunction createSelectObservable(selector) {\n    if (!SelectFactory.store) {\n        throwSelectFactoryNotConnectedError();\n    }\n    return SelectFactory.store.select(selector);\n}\nfunction createSelectorFn(name, rawSelector, paths = []) {\n    rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n    if (typeof rawSelector === 'string') {\n        const propsArray = paths.length\n            ? [rawSelector, ...paths]\n            : rawSelector.split('.');\n        return propGetter(propsArray, SelectFactory.config);\n    }\n    return rawSelector;\n}\n/**\n * @example If `foo$` => make it just `foo`\n */\nfunction removeDollarAtTheEnd(name) {\n    const lastCharIndex = name.length - 1;\n    const dollarAtTheEnd = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n    return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nfunction Select(rawSelector, ...paths) {\n    return function (target, key) {\n        const name = key.toString();\n        const selectorId = `__${name}__selector`;\n        const selector = createSelectorFn(name, rawSelector, paths);\n        Object.defineProperties(target, {\n            [selectorId]: {\n                writable: true,\n                enumerable: false,\n                configurable: true\n            },\n            [name]: {\n                enumerable: true,\n                configurable: true,\n                get() {\n                    return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n                }\n            }\n        });\n    };\n}\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\nconst selectorOptionsMetaAccessor = {\n    getOptions: (target) => {\n        return (target && target[SELECTOR_OPTIONS_META_KEY]) || {};\n    },\n    defineOptions: (target, options) => {\n        if (!target)\n            return;\n        target[SELECTOR_OPTIONS_META_KEY] = options;\n    },\n};\nfunction setupSelectorMetadata(originalFn, creationMetadata) {\n    const selectorMetaData = ensureSelectorMetadata$1(originalFn);\n    selectorMetaData.originalFn = originalFn;\n    let getExplicitSelectorOptions = () => ({});\n    if (creationMetadata) {\n        selectorMetaData.containerClass = creationMetadata.containerClass;\n        selectorMetaData.selectorName = creationMetadata.selectorName || null;\n        getExplicitSelectorOptions =\n            creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n    }\n    const selectorMetaDataClone = Object.assign({}, selectorMetaData);\n    selectorMetaData.getSelectorOptions = () => getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n    return selectorMetaData;\n}\nfunction getLocalSelectorOptions(selectorMetaData, explicitOptions) {\n    return Object.assign(Object.assign(Object.assign(Object.assign({}, (selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {})), (selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {})), (selectorMetaData.getSelectorOptions() || {})), explicitOptions);\n}\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nfunction SelectorOptions(options) {\n    return (function decorate(target, methodName, descriptor) {\n        if (methodName) {\n            descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, methodName));\n            // Method Decorator\n            const originalFn = descriptor.value || descriptor.originalFn;\n            if (originalFn) {\n                selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n            }\n        }\n        else {\n            // Class Decorator\n            selectorOptionsMetaAccessor.defineOptions(target, options);\n        }\n    });\n}\n\nfunction ensureStoreMetadata(target) {\n    return ensureStoreMetadata$1(target);\n}\nfunction getStoreMetadata(target) {\n    return getStoreMetadata$1(target);\n}\nfunction ensureSelectorMetadata(target) {\n    return ensureSelectorMetadata$1(target);\n}\nfunction getSelectorMetadata(target) {\n    return getSelectorMetadata$1(target);\n}\n\nfunction createSelector(selectors, projector, creationMetadata) {\n    const memoizedFn = createMemoizedSelectorFn(projector, creationMetadata);\n    const selectorMetaData = setupSelectorMetadata(projector, creationMetadata);\n    selectorMetaData.makeRootSelector = createRootSelectorFactory(selectorMetaData, selectors, memoizedFn);\n    return memoizedFn;\n}\n\nfunction Selector(selectors) {\n    return (target, key, descriptor) => {\n        descriptor || (descriptor = Object.getOwnPropertyDescriptor(target, key));\n        const originalFn = descriptor === null || descriptor === void 0 ? void 0 : descriptor.value;\n        // Caretaker note: we have still left the `typeof` condition in order to avoid\n        // creating a breaking change for projects that still use the View Engine.\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (originalFn && typeof originalFn !== 'function') {\n                throwSelectorDecoratorError();\n            }\n        }\n        const memoizedFn = createSelector(selectors, originalFn, {\n            containerClass: target,\n            selectorName: key.toString(),\n            getSelectorOptions() {\n                return {};\n            },\n        });\n        const newDescriptor = {\n            configurable: true,\n            get() {\n                return memoizedFn;\n            },\n        };\n        // Add hidden property to descriptor\n        newDescriptor['originalFn'] = originalFn;\n        return newDescriptor;\n    };\n}\n\nclass StateToken {\n    constructor(name) {\n        this.name = name;\n        const selectorMetadata = ensureSelectorMetadata$1(this);\n        selectorMetadata.makeRootSelector = (runtimeContext) => {\n            return runtimeContext.getStateGetter(this.name);\n        };\n    }\n    getName() {\n        return this.name;\n    }\n    toString() {\n        return `StateToken[${this.name}]`;\n    }\n}\n\nclass NgxsDevelopmentModule {\n    static forRoot(options) {\n        return {\n            ngModule: NgxsDevelopmentModule,\n            providers: [\n                NgxsUnhandledActionsLogger,\n                { provide: NGXS_DEVELOPMENT_OPTIONS, useValue: options }\n            ]\n        };\n    }\n}\n/** @nocollapse */ NgxsDevelopmentModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\n/** @nocollapse */ NgxsDevelopmentModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"12.2.17\", ngImport: i0, type: NgxsDevelopmentModule, decorators: [{\n            type: NgModule\n        }] });\n\nfunction ensureValidSelector(selector, context = {}) {\n    const noun = context.noun || 'selector';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    ensureValueProvided(selector, { noun, prefix: context.prefix });\n    const metadata = getSelectorMetadata$1(selector) || getStoreMetadata$1(selector);\n    if (!metadata) {\n        throw new Error(`${prefix}The value provided as the ${noun} is not a valid selector.`);\n    }\n}\nfunction ensureValueProvided(value, context = {}) {\n    const noun = context.noun || 'value';\n    const prefix = context.prefix ? context.prefix + ': ' : '';\n    if (!value) {\n        throw new Error(`${prefix}A ${noun} must be provided.`);\n    }\n}\n\nfunction createModelSelector(selectorMap) {\n    const selectorKeys = Object.keys(selectorMap);\n    const selectors = Object.values(selectorMap);\n    ensureValidSelectorMap({\n        prefix: '[createModelSelector]',\n        selectorMap,\n        selectorKeys,\n        selectors,\n    });\n    return createSelector(selectors, (...args) => {\n        return selectorKeys.reduce((obj, key, index) => {\n            obj[key] = args[index];\n            return obj;\n        }, {});\n    });\n}\nfunction ensureValidSelectorMap({ prefix, selectorMap, selectorKeys, selectors, }) {\n    ensureValueProvided(selectorMap, { prefix, noun: 'selector map' });\n    ensureValueProvided(typeof selectorMap === 'object', { prefix, noun: 'valid selector map' });\n    ensureValueProvided(selectorKeys.length, { prefix, noun: 'non-empty selector map' });\n    selectors.forEach((selector, index) => ensureValidSelector(selector, {\n        prefix,\n        noun: `selector for the '${selectorKeys[index]}' property`,\n    }));\n}\n\nfunction createPickSelector(selector, keys) {\n    ensureValidSelector(selector, { prefix: '[createPickSelector]' });\n    const validKeys = keys.filter(Boolean);\n    const selectors = validKeys.map((key) => createSelector([selector], (s) => s[key]));\n    return createSelector([...selectors], (...props) => {\n        return validKeys.reduce((acc, key, index) => {\n            acc[key] = props[index];\n            return acc;\n        }, {});\n    });\n}\n\nfunction createPropertySelectors(parentSelector) {\n    ensureValidSelector(parentSelector, {\n        prefix: '[createPropertySelectors]',\n        noun: 'parent selector',\n    });\n    const cache = {};\n    return new Proxy({}, {\n        get(_target, prop) {\n            const selector = cache[prop] ||\n                createSelector([parentSelector], (s) => s === null || s === void 0 ? void 0 : s[prop]);\n            cache[prop] = selector;\n            return selector;\n        },\n    });\n}\n\n/**\n * The public api for consumers of @ngxs/store\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Action, Actions, InitState, NGXS_PLUGINS, NgxsDevelopmentModule, NgxsModule, NgxsSimpleChange, NgxsUnhandledActionsLogger, NoopNgxsExecutionStrategy, Select, Selector, SelectorOptions, State, StateStream, StateToken, Store, UpdateState, actionMatcher, createModelSelector, createPickSelector, createPropertySelectors, createSelector, ensureSelectorMetadata, ensureStoreMetadata, getActionTypeFromInstance, getSelectorMetadata, getStoreMetadata, getValue, ofAction, ofActionCanceled, ofActionCompleted, ofActionDispatched, ofActionErrored, ofActionSuccessful, setValue, NgxsFeatureModule as ɵNgxsFeatureModule, NgxsRootModule as ɵNgxsRootModule };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}